/**
 * Case AI Functions
 *
 * AI-powered entity extraction and content generation for cases.
 */

import type { Database, Json } from "@odis-ai/shared/types";
import type { SupabaseClientType } from "@odis-ai/shared/types/supabase";
import type { NormalizedEntities } from "@odis-ai/shared/validators";
import type { AIGeneratedCallIntelligence } from "@odis-ai/integrations/vapi/types";
import type { CaseMetadata } from "@odis-ai/shared/types/case";
import { parseBillingString } from "@odis-ai/shared/types/idexx";

/**
 * Auto-generate structured discharge summary for IDEXX Neo cases
 */
export async function autoGenerateDischargeSummary(
  supabase: SupabaseClientType,
  userId: string,
  caseId: string,
  entities: NormalizedEntities,
): Promise<{ summaryId: string } | null> {
  try {
    const { data: existingSummaries } = await supabase
      .from("discharge_summaries")
      .select("id")
      .eq("case_id", caseId)
      .limit(1);

    if (existingSummaries && existingSummaries.length > 0) {
      console.log(
        "[CaseAI] Discharge summary already exists, skipping auto-generation",
        { caseId, existingSummaryId: existingSummaries[0]?.id },
      );
      return null;
    }

    const hasMinimumData =
      entities.patient.name &&
      (Boolean(entities.clinical.diagnoses?.length) ||
        Boolean(entities.clinical.chiefComplaint) ||
        Boolean(entities.clinical.visitReason));

    if (!hasMinimumData) {
      console.log("[CaseAI] Insufficient data for auto-generation", {
        caseId,
        hasPatientName: !!entities.patient.name,
        hasDiagnoses: !!entities.clinical.diagnoses?.length,
        hasChiefComplaint: !!entities.clinical.chiefComplaint,
      });
      return null;
    }

    console.log("[CaseAI] Auto-generating discharge summary for IDEXX case", {
      caseId,
      patientName: entities.patient.name,
    });

    const { generateStructuredDischargeSummaryWithRetry } =
      await import("@odis-ai/integrations/ai/generate-structured-discharge");
    const { structured, plainText } =
      await generateStructuredDischargeSummaryWithRetry({
        entityExtraction: entities,
        patientData: {
          name: entities.patient.name,
          species: entities.patient.species,
          breed: entities.patient.breed,
          owner_name: entities.patient.owner.name,
        },
      });

    const { data: summary, error } = await supabase
      .from("discharge_summaries")
      .insert({
        case_id: caseId,
        user_id: userId,
        content: plainText,
        structured_content: structured as unknown as Json,
      })
      .select("id")
      .single();

    if (error) {
      console.error("[CaseAI] Failed to save auto-generated summary", {
        caseId,
        error: error.message,
      });
      return null;
    }

    console.log("[CaseAI] Successfully auto-generated discharge summary", {
      caseId,
      summaryId: summary.id,
      patientName: structured.patientName,
    });

    return { summaryId: summary.id };
  } catch (error) {
    console.error("[CaseAI] Auto-generation failed", {
      caseId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Extract entities from IDEXX consultation notes using AI
 */
export async function extractEntitiesFromIdexx(
  rawIdexxData: Record<string, unknown>,
): Promise<NormalizedEntities | null> {
  try {
    const consultationNotes = rawIdexxData.consultation_notes as
      | string
      | undefined;

    if (!consultationNotes || consultationNotes.length < 50) {
      console.log(
        "[CaseAI] Insufficient consultation notes for AI extraction",
        {
          hasNotes: !!consultationNotes,
          length: consultationNotes?.length ?? 0,
        },
      );
      return null;
    }

    const cleanedText = consultationNotes
      .replace(/<[^>]*>/g, " ")
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&amp;/g, "&")
      .replace(/&nbsp;/g, " ")
      .replace(/\s+/g, " ")
      .trim();

    if (cleanedText.length < 50) {
      console.log(
        "[CaseAI] Cleaned consultation notes too short for AI extraction",
        {
          cleanedLength: cleanedText.length,
        },
      );
      return null;
    }

    const isEuthanasia =
      cleanedText.toLowerCase().includes("euthanasia") ||
      cleanedText.toLowerCase().includes("euthanize") ||
      (rawIdexxData.appointment_type as string | undefined)
        ?.toLowerCase()
        .includes("euthanasia");

    if (isEuthanasia) {
      console.warn(
        "[CaseAI] Euthanasia case detected - skipping AI extraction",
        {
          source: "idexx_consultation_notes",
        },
      );
      return null;
    }

    console.log("[CaseAI] Extracting entities from IDEXX consultation notes", {
      textLength: cleanedText.length,
    });

    const { extractEntitiesWithRetry } =
      await import("@odis-ai/integrations/ai/normalize-scribe");
    const entities = await extractEntitiesWithRetry(
      cleanedText,
      "idexx_consultation_notes",
    );

    // Enrich with IDEXX metadata
    if (rawIdexxData.pet_name) {
      entities.patient.name = rawIdexxData.pet_name as string;
    }
    if (rawIdexxData.species) {
      const species = (rawIdexxData.species as string).toLowerCase();
      const validSpecies = [
        "dog",
        "cat",
        "bird",
        "rabbit",
        "other",
        "unknown",
      ] as const;
      type ValidSpecies = (typeof validSpecies)[number];
      entities.patient.species = validSpecies.includes(species as ValidSpecies)
        ? (species as ValidSpecies)
        : "unknown";
    }
    if (rawIdexxData.breed) {
      entities.patient.breed = rawIdexxData.breed as string;
    }

    const clientFirstName = rawIdexxData.client_first_name as
      | string
      | undefined;
    const clientLastName = rawIdexxData.client_last_name as string | undefined;
    const ownerName = rawIdexxData.owner_name as string | undefined;
    if (clientFirstName && clientLastName) {
      entities.patient.owner.name = `${clientFirstName} ${clientLastName}`;
    } else if (ownerName) {
      entities.patient.owner.name = ownerName;
    }

    const phone =
      (rawIdexxData.phone_number as string | undefined) ??
      (rawIdexxData.mobile_number as string | undefined);
    if (phone) {
      entities.patient.owner.phone = phone;
    }
    const email = rawIdexxData.email as string | undefined;
    if (email) {
      entities.patient.owner.email = email;
    }

    const acceptedItems = parseBillingString(
      rawIdexxData.products_services as string | undefined,
      false,
    );
    const declinedItems = parseBillingString(
      rawIdexxData.declined_products_services as string | undefined,
      true,
    );

    if (acceptedItems.length > 0) {
      entities.clinical.productsServicesProvided = acceptedItems.map((item) =>
        item.quantity > 1
          ? `${item.productService} (Qty: ${item.quantity})`
          : item.productService,
      );
    }
    if (declinedItems.length > 0) {
      entities.clinical.productsServicesDeclined = declinedItems.map((item) =>
        item.quantity > 1
          ? `${item.productService} (Qty: ${item.quantity})`
          : item.productService,
      );
    }

    console.log("[CaseAI] Successfully extracted entities from IDEXX notes", {
      patientName: entities.patient.name,
      hasOwnerPhone: !!entities.patient.owner.phone,
      diagnosesCount: entities.clinical.diagnoses?.length ?? 0,
      medicationsCount: entities.clinical.medications?.length ?? 0,
      confidence: entities.confidence?.overall,
    });

    return entities;
  } catch (error) {
    console.error("[CaseAI] Failed to extract entities from IDEXX notes", {
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Generate and store AI call intelligence at ingest-time
 */
export async function generateAndStoreCallIntelligence(
  supabase: SupabaseClientType,
  caseId: string,
  entities: NormalizedEntities,
): Promise<AIGeneratedCallIntelligence | null> {
  try {
    const hasMinimumData =
      entities.patient.name &&
      (Boolean(entities.clinical.diagnoses?.length) ||
        Boolean(entities.clinical.chiefComplaint) ||
        Boolean(entities.clinical.visitReason) ||
        Boolean(entities.clinical.medications?.length));

    if (!hasMinimumData) {
      console.log(
        "[CaseAI] Insufficient data for call intelligence generation",
        {
          caseId,
          hasPatientName: !!entities.patient.name,
          hasDiagnoses: !!entities.clinical.diagnoses?.length,
          hasMedications: !!entities.clinical.medications?.length,
        },
      );
      return null;
    }

    console.log("[CaseAI] Pre-generating call intelligence at ingest", {
      caseId,
      petName: entities.patient.name,
      diagnosis: entities.clinical.diagnoses?.[0],
    });

    const { generateCallIntelligenceFromEntities } =
      await import("@odis-ai/integrations/ai/generate-assessment-questions");
    const intelligence = await generateCallIntelligenceFromEntities(entities);

    const { data: caseData } = await supabase
      .from("cases")
      .select("metadata")
      .eq("id", caseId)
      .single();

    const currentMetadata = (caseData?.metadata as CaseMetadata) ?? {};
    const updatedMetadata: CaseMetadata = {
      ...currentMetadata,
      callIntelligence: {
        ...intelligence,
        generatedAt: new Date().toISOString(),
      },
    };

    const { error: updateError } = await supabase
      .from("cases")
      .update({ metadata: updatedMetadata as Json })
      .eq("id", caseId);

    if (updateError) {
      console.error("[CaseAI] Failed to store call intelligence in metadata", {
        caseId,
        error: updateError.message,
      });
      return null;
    }

    console.log("[CaseAI] Successfully stored call intelligence", {
      caseId,
      questionCount: intelligence.assessmentQuestions?.length ?? 0,
      callApproach: intelligence.callApproach,
      shouldAskQuestions: intelligence.shouldAskClinicalQuestions,
      confidence: intelligence.confidence,
    });

    return intelligence;
  } catch (error) {
    console.error("[CaseAI] Failed to generate call intelligence", {
      caseId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}
