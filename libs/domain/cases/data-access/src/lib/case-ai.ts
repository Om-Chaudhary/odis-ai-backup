/**
 * Case AI Functions
 *
 * AI-powered entity extraction and content generation for cases.
 */

import type { Json } from "@odis-ai/shared/types";
import type { SupabaseClientType } from "@odis-ai/shared/types/supabase";
import type { NormalizedEntities } from "@odis-ai/shared/validators";
import type { AIGeneratedCallIntelligence } from "@odis-ai/integrations/vapi/types";
import type { CaseMetadata } from "@odis-ai/shared/types/case";
import { enrichEntitiesWithIdexxMetadata } from "./entity-utils";

/**
 * Auto-generate structured discharge summary for IDEXX Neo cases
 */
export async function autoGenerateDischargeSummary(
  supabase: SupabaseClientType,
  userId: string,
  caseId: string,
  entities: NormalizedEntities,
): Promise<{ summaryId: string } | null> {
  try {
    const { data: existingSummaries } = await supabase
      .from("discharge_summaries")
      .select("id")
      .eq("case_id", caseId)
      .limit(1);

    if (existingSummaries && existingSummaries.length > 0) {
      console.log(
        "[CaseAI] Discharge summary already exists, skipping auto-generation",
        { caseId, existingSummaryId: existingSummaries[0]?.id },
      );
      return null;
    }

    const hasMinimumData =
      entities.patient.name &&
      (Boolean(entities.clinical.diagnoses?.length) ||
        Boolean(entities.clinical.chiefComplaint) ||
        Boolean(entities.clinical.visitReason));

    if (!hasMinimumData) {
      console.log("[CaseAI] Insufficient data for auto-generation", {
        caseId,
        hasPatientName: !!entities.patient.name,
        hasDiagnoses: !!entities.clinical.diagnoses?.length,
        hasChiefComplaint: !!entities.clinical.chiefComplaint,
      });
      return null;
    }

    console.log("[CaseAI] Auto-generating discharge summary for IDEXX case", {
      caseId,
      patientName: entities.patient.name,
    });

    const { generateStructuredDischargeSummaryWithRetry } =
      await import("@odis-ai/integrations/ai/generate-structured-discharge");
    const { structured, plainText } =
      await generateStructuredDischargeSummaryWithRetry({
        entityExtraction: entities,
        patientData: {
          name: entities.patient.name,
          species: entities.patient.species,
          breed: entities.patient.breed,
          owner_name: entities.patient.owner.name,
        },
      });

    const { data: summary, error } = await supabase
      .from("discharge_summaries")
      .insert({
        case_id: caseId,
        user_id: userId,
        content: plainText,
        structured_content: structured as unknown as Json,
      })
      .select("id")
      .single();

    if (error) {
      console.error("[CaseAI] Failed to save auto-generated summary", {
        caseId,
        error: error.message,
      });
      return null;
    }

    console.log("[CaseAI] Successfully auto-generated discharge summary", {
      caseId,
      summaryId: summary.id,
      patientName: structured.patientName,
    });

    return { summaryId: summary.id };
  } catch (error) {
    console.error("[CaseAI] Auto-generation failed", {
      caseId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Extract entities from IDEXX consultation notes using AI
 */
export async function extractEntitiesFromIdexx(
  rawIdexxData: Record<string, unknown>,
): Promise<NormalizedEntities | null> {
  try {
    const consultationNotes = rawIdexxData.consultation_notes as
      | string
      | undefined;

    if (!consultationNotes || consultationNotes.length < 50) {
      console.log(
        "[CaseAI] Insufficient consultation notes for AI extraction",
        {
          hasNotes: !!consultationNotes,
          length: consultationNotes?.length ?? 0,
        },
      );
      return null;
    }

    const cleanedText = consultationNotes
      .replace(/<[^>]*>/g, " ")
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&amp;/g, "&")
      .replace(/&nbsp;/g, " ")
      .replace(/\s+/g, " ")
      .trim();

    if (cleanedText.length < 50) {
      console.log(
        "[CaseAI] Cleaned consultation notes too short for AI extraction",
        {
          cleanedLength: cleanedText.length,
        },
      );
      return null;
    }

    const isEuthanasia =
      cleanedText.toLowerCase().includes("euthanasia") ||
      cleanedText.toLowerCase().includes("euthanize") ||
      (rawIdexxData.appointment_type as string | undefined)
        ?.toLowerCase()
        .includes("euthanasia");

    if (isEuthanasia) {
      console.warn(
        "[CaseAI] Euthanasia case detected - skipping AI extraction",
        {
          source: "idexx_consultation_notes",
        },
      );
      return null;
    }

    console.log("[CaseAI] Extracting entities from IDEXX consultation notes", {
      textLength: cleanedText.length,
    });

    const { extractEntitiesWithRetry } =
      await import("@odis-ai/integrations/ai/normalize-scribe");
    const entities = await extractEntitiesWithRetry(
      cleanedText,
      "idexx_consultation_notes",
    );

    enrichEntitiesWithIdexxMetadata(entities, rawIdexxData);

    console.log("[CaseAI] Successfully extracted entities from IDEXX notes", {
      patientName: entities.patient.name,
      hasOwnerPhone: !!entities.patient.owner.phone,
      diagnosesCount: entities.clinical.diagnoses?.length ?? 0,
      medicationsCount: entities.clinical.medications?.length ?? 0,
      confidence: entities.confidence?.overall,
    });

    return entities;
  } catch (error) {
    console.error("[CaseAI] Failed to extract entities from IDEXX notes", {
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Generate and store AI call intelligence at ingest-time
 */
export async function generateAndStoreCallIntelligence(
  supabase: SupabaseClientType,
  caseId: string,
  entities: NormalizedEntities,
): Promise<AIGeneratedCallIntelligence | null> {
  try {
    const hasMinimumData =
      entities.patient.name &&
      (Boolean(entities.clinical.diagnoses?.length) ||
        Boolean(entities.clinical.chiefComplaint) ||
        Boolean(entities.clinical.visitReason) ||
        Boolean(entities.clinical.medications?.length));

    if (!hasMinimumData) {
      console.log(
        "[CaseAI] Insufficient data for call intelligence generation",
        {
          caseId,
          hasPatientName: !!entities.patient.name,
          hasDiagnoses: !!entities.clinical.diagnoses?.length,
          hasMedications: !!entities.clinical.medications?.length,
        },
      );
      return null;
    }

    console.log("[CaseAI] Pre-generating call intelligence at ingest", {
      caseId,
      petName: entities.patient.name,
      diagnosis: entities.clinical.diagnoses?.[0],
    });

    const { generateCallIntelligenceFromEntities } =
      await import("@odis-ai/integrations/ai/generate-assessment-questions");
    const intelligence = await generateCallIntelligenceFromEntities(entities);

    const { data: caseData } = await supabase
      .from("cases")
      .select("metadata")
      .eq("id", caseId)
      .single();

    const currentMetadata = (caseData?.metadata as CaseMetadata) ?? {};
    const updatedMetadata: CaseMetadata = {
      ...currentMetadata,
      callIntelligence: {
        ...intelligence,
        generatedAt: new Date().toISOString(),
      },
    };

    const { error: updateError } = await supabase
      .from("cases")
      .update({ metadata: updatedMetadata as Json })
      .eq("id", caseId);

    if (updateError) {
      console.error("[CaseAI] Failed to store call intelligence in metadata", {
        caseId,
        error: updateError.message,
      });
      return null;
    }

    console.log("[CaseAI] Successfully stored call intelligence", {
      caseId,
      questionCount: intelligence.assessmentQuestions?.length ?? 0,
      callApproach: intelligence.callApproach,
      shouldAskQuestions: intelligence.shouldAskClinicalQuestions,
      confidence: intelligence.confidence,
    });

    return intelligence;
  } catch (error) {
    console.error("[CaseAI] Failed to generate call intelligence", {
      caseId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}
