import { type NormalizedEntities } from "@odis-ai/validators/scribe";
import { extractEntitiesWithRetry } from "@odis-ai/ai/normalize-scribe";
import { generateStructuredDischargeSummaryWithRetry } from "@odis-ai/ai/generate-structured-discharge";
import { generateCallIntelligenceFromEntities } from "@odis-ai/ai/generate-assessment-questions";
import { scheduleCallExecution } from "@odis-ai/qstash/client";
import { buildDynamicVariables } from "@odis-ai/vapi/knowledge-base";
import type { AIGeneratedCallIntelligence } from "@odis-ai/vapi/types";
import { extractVapiVariablesFromEntities } from "@odis-ai/vapi/extract-variables";
import {
  extractFirstName,
  normalizeVariablesToSnakeCase,
} from "@odis-ai/vapi/utils";
import { normalizeToE164 } from "@odis-ai/utils/phone";
import { getClinicVapiConfigByUserId } from "@odis-ai/clinics/vapi-config";

// Type imports
import type { Database, Json } from "@odis-ai/types";
import type { SupabaseClientType } from "@odis-ai/types/supabase";
import type {
  CaseScheduleOptions,
  IngestPayload,
  ScheduledCallMetadata,
  ScheduledDischargeCall,
} from "@odis-ai/types/services";
import type { CaseMetadata, CaseMetadataJson } from "@odis-ai/types/case";
import {
  buildIdexxConsultationData,
  parseBillingString,
} from "@odis-ai/types/idexx";

// Re-export types for convenience
export type { CaseScheduleOptions, IngestPayload, ScheduledDischargeCall };

/* ========================================
   Type Aliases
   ======================================== */

/**
 * Database table row types
 */
type CaseRow = Database["public"]["Tables"]["cases"]["Row"];
type CaseInsert = Database["public"]["Tables"]["cases"]["Insert"];
type CaseUpdate = Database["public"]["Tables"]["cases"]["Update"];
type ScheduledCallRow =
  Database["public"]["Tables"]["scheduled_discharge_calls"]["Row"];
type ScheduledCallInsert =
  Database["public"]["Tables"]["scheduled_discharge_calls"]["Insert"];

type PatientRow = Database["public"]["Tables"]["patients"]["Row"];
type PatientInsert = Database["public"]["Tables"]["patients"]["Insert"];

type TranscriptionInsert =
  Database["public"]["Tables"]["transcriptions"]["Insert"];

/* ========================================
   Service Implementation
   ======================================== */

export const CasesService = {
  /**
   * Main entry point for ingesting case data
   */
  async ingest(
    supabase: SupabaseClientType,
    userId: string,
    payload: IngestPayload,
  ): Promise<{
    caseId: string;
    entities: NormalizedEntities;
    scheduledCall: ScheduledDischargeCall | null;
  }> {
    let entities: NormalizedEntities | null = null;
    let rawIdexxData: Record<string, unknown> | null = null;
    let transcriptionText: string | null = null;

    // 1. Normalize Data
    if (payload.mode === "text") {
      transcriptionText = payload.text;
      // Run AI Normalization
      entities = await extractEntitiesWithRetry(
        payload.text,
        payload.options?.inputType,
      );
    } else {
      // Mode: structured (IDEXX)
      rawIdexxData = payload.data;
      // Check if payload.data looks like NormalizedEntities
      if (payload.data.patient && payload.data.clinical) {
        entities = payload.data as NormalizedEntities;
      } else {
        entities = mapIdexxToEntities(payload.data);
      }
    }

    if (!entities) {
      throw new Error("Failed to extract entities from payload");
    }

    // 2. Find or Create Case (Smart Merge)
    const caseResult = await this.createOrUpdateCase(
      supabase,
      userId,
      entities,
      {
        rawIdexxData,
        transcriptionText,
        source: payload.source,
      },
    );

    // 3. Auto-generate discharge summary for IDEXX Neo cases
    if (payload.source === "idexx_extension") {
      await this.autoGenerateDischargeSummary(
        supabase,
        userId,
        caseResult.caseId,
        caseResult.entities,
      );
    }

    // 4. Auto-Schedule if requested
    let scheduledCall = null;
    if (payload.options?.autoSchedule) {
      const scheduledAt = new Date(); // Immediate/Queued

      scheduledCall = await this.scheduleDischargeCall(
        supabase,
        userId,
        caseResult.caseId,
        {
          scheduledAt,
        },
      );
    }

    return {
      caseId: caseResult.caseId,
      entities: caseResult.entities,
      scheduledCall,
    };
  },

  /**
   * Find existing case or create new one, merging data
   */
  async createOrUpdateCase(
    supabase: SupabaseClientType,
    userId: string,
    entities: NormalizedEntities,
    context: {
      rawIdexxData?: Record<string, unknown> | null;
      transcriptionText?: string | null;
      source: string;
    },
  ): Promise<{
    caseId: string;
    entities: NormalizedEntities;
  }> {
    let caseId: string | null = null;

    // 1. FIRST: Check by external_id (IDEXX appointment ID) - exact match, highest priority
    // This prevents duplicate cases from being created for the same IDEXX appointment
    const idexxAppointmentId =
      (context.rawIdexxData?.appointmentId as string | undefined) ??
      (context.rawIdexxData?.id as string | undefined);

    if (idexxAppointmentId && context.source === "idexx_extension") {
      const externalId = `idexx-appt-${idexxAppointmentId}`;
      const { data: existingByExtId, error: extIdError } = await supabase
        .from("cases")
        .select("id")
        .eq("external_id", externalId)
        .eq("user_id", userId)
        .maybeSingle();

      if (extIdError) {
        console.error("[CasesService] Error checking external_id:", extIdError);
      }

      if (existingByExtId) {
        console.log("[CasesService] Found existing case by external_id", {
          externalId,
          caseId: existingByExtId.id,
        });
        caseId = existingByExtId.id;
      }
    }

    // 2. FALLBACK: Try to find existing case by patient name and owner (case-insensitive)
    // Only if we didn't find by external_id
    if (!caseId) {
      // Discharges can be sent anytime after a case is created, so we look for
      // cases within a reasonable window (90 days) that are ongoing or completed
      const ninetyDaysAgo = new Date();
      ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
      ninetyDaysAgo.setHours(0, 0, 0, 0);

      // First find matching patients (case-insensitive)
      const { data: matchingPatients, error: patientSearchError } =
        await supabase
          .from("patients")
          .select("case_id")
          .eq("user_id", userId)
          .ilike("name", entities.patient.name)
          .ilike("owner_name", entities.patient.owner.name ?? "")
          .not("case_id", "is", null);

      if (patientSearchError) {
        console.error(
          "[CasesService] Error searching for patients:",
          patientSearchError,
        );
      }

      // If we found matching patients, get their cases
      if (matchingPatients && matchingPatients.length > 0) {
        const caseIds = matchingPatients
          .map((p) => p.case_id)
          .filter((id): id is string => id !== null);

        if (caseIds.length > 0) {
          const { data: existingCases, error: caseSearchError } = await supabase
            .from("cases")
            .select("id, status, created_at")
            .in("id", caseIds)
            .in("status", ["ongoing", "completed"])
            .gte("created_at", ninetyDaysAgo.toISOString())
            .order("created_at", { ascending: false })
            .limit(1);

          if (caseSearchError) {
            console.error(
              "[CasesService] Error searching for cases:",
              caseSearchError,
            );
          }

          if (existingCases && existingCases.length > 0) {
            const match = existingCases[0];
            if (match) {
              console.log(
                "[CasesService] Found existing case by patient/owner name",
                {
                  patientName: entities.patient.name,
                  ownerName: entities.patient.owner.name,
                  caseId: match.id,
                },
              );
              caseId = match.id;
            }
          }
        }
      }
    }

    if (caseId) {
      // Update Existing Case (Merge)
      const { data: currentCase, error: fetchError } = await supabase
        .from("cases")
        .select("metadata")
        .eq("id", caseId)
        .single();

      if (fetchError) {
        throw new Error(`Failed to fetch existing case: ${fetchError.message}`);
      }

      const currentMetadata =
        (currentCase?.metadata as CaseMetadata | undefined) ?? {};
      const currentEntities = currentMetadata.entities;

      const mergedEntities = this.mergeEntities(currentEntities, entities);

      // Build structured IDEXX metadata with raw data and parsed consultation
      const newIdexx = context.rawIdexxData
        ? {
            raw: context.rawIdexxData,
            consultation: buildIdexxConsultationData(context.rawIdexxData),
          }
        : (currentMetadata.idexx ?? null);

      const updateData: CaseUpdate = {
        metadata: {
          ...currentMetadata,
          entities: mergedEntities,
          idexx: newIdexx,
          last_updated_by: context.source,
        } as CaseMetadata as CaseMetadataJson,
        updated_at: new Date().toISOString(),
      };

      const { error: updateError } = await supabase
        .from("cases")
        .update(updateData)
        .eq("id", caseId);

      if (updateError) {
        throw new Error(`Failed to update case: ${updateError.message}`);
      }
    } else {
      // Create New Case
      // Generate external_id for IDEXX cases to enable future deduplication
      const idexxAppointmentId =
        (context.rawIdexxData?.appointmentId as string | undefined) ??
        (context.rawIdexxData?.id as string | undefined);
      const externalId =
        context.source === "idexx_extension" && idexxAppointmentId
          ? `idexx-appt-${idexxAppointmentId}`
          : null;

      // Build structured IDEXX metadata with raw data and parsed consultation
      const idexxMetadata = context.rawIdexxData
        ? {
            raw: context.rawIdexxData,
            consultation: buildIdexxConsultationData(context.rawIdexxData),
          }
        : null;

      const caseInsert: CaseInsert = {
        user_id: userId,
        status: "ongoing",
        type: mapCaseTypeToDb(entities.caseType),
        source: context.source,
        external_id: externalId,
        metadata: {
          entities: entities,
          idexx: idexxMetadata,
        } as CaseMetadata as CaseMetadataJson,
      };

      const { data: newCase, error: caseError } = await supabase
        .from("cases")
        .insert(caseInsert)
        .select()
        .single();

      if (caseError || !newCase) {
        throw new Error(
          `Failed to create case: ${caseError?.message ?? "Unknown error"}`,
        );
      }
      caseId = newCase.id;

      console.log("[CasesService] Created new case", {
        caseId,
        externalId,
        source: context.source,
      });

      // Patient Deduplication: Find existing patient or create new one
      // First, try to find an existing patient with matching name and owner (case-insensitive)
      const { data: existingPatient, error: patientSearchError } =
        await supabase
          .from("patients")
          .select("id, name, owner_name")
          .eq("user_id", userId)
          .ilike("name", entities.patient.name)
          .ilike("owner_name", entities.patient.owner.name ?? "")
          .order("created_at", { ascending: false })
          .limit(1)
          .maybeSingle();

      if (patientSearchError) {
        console.error(
          "[CasesService] Error searching for existing patient:",
          patientSearchError,
        );
      }

      if (existingPatient) {
        // Reuse existing patient - update their case_id to link to this new case
        // Also update any new information we have
        const { error: updatePatientError } = await supabase
          .from("patients")
          .update({
            case_id: caseId,
            // Update with any new/better data from entities
            species: entities.patient.species ?? undefined,
            breed: entities.patient.breed ?? undefined,
            sex: entities.patient.sex ?? undefined,
            weight_kg: parseWeight(entities.patient.weight) ?? undefined,
            owner_phone: entities.patient.owner.phone ?? undefined,
            owner_email: entities.patient.owner.email ?? undefined,
            updated_at: new Date().toISOString(),
          })
          .eq("id", existingPatient.id);

        if (updatePatientError) {
          console.error(
            "[CasesService] Error updating existing patient:",
            updatePatientError,
          );
        } else {
          console.log("[CasesService] Reused existing patient", {
            patientId: existingPatient.id,
            patientName: existingPatient.name,
            caseId,
          });
        }
      } else {
        // Create new patient record
        const patientInsert: PatientInsert = {
          user_id: userId,
          case_id: caseId,
          name: entities.patient.name,
          species: entities.patient.species ?? null,
          breed: entities.patient.breed ?? null,
          sex: entities.patient.sex ?? null,
          weight_kg: parseWeight(entities.patient.weight),
          owner_name: entities.patient.owner.name ?? null,
          owner_phone: entities.patient.owner.phone ?? null,
          owner_email: entities.patient.owner.email ?? null,
        };

        const { data: newPatient, error: patientError } = await supabase
          .from("patients")
          .insert(patientInsert)
          .select()
          .single();

        if (patientError) {
          console.error("[CasesService] Error creating patient:", patientError);
          // Don't throw - case was created successfully, patient is optional
        } else if (newPatient) {
          console.log("[CasesService] Created new patient", {
            patientId: newPatient.id,
            patientName: newPatient.name,
            caseId,
          });
        }
      }
    }

    // Handle Transcription
    if (context.transcriptionText && caseId) {
      const transcriptionInsert: TranscriptionInsert = {
        case_id: caseId,
        user_id: userId,
        transcript: context.transcriptionText,
        processing_status: "completed",
      };

      const { error: transcriptionError } = await supabase
        .from("transcriptions")
        .insert(transcriptionInsert);

      if (transcriptionError) {
        console.error(
          "[CasesService] Error creating transcription:",
          transcriptionError,
        );
        // Don't throw - transcription is optional
      }
    }

    // TypeScript doesn't know caseId is guaranteed to be set, but logically it always is
    // (either from existing case or newly created case)
    if (!caseId) {
      throw new Error("Failed to create or find case");
    }

    return { caseId, entities };
  },

  /**
   * Get case with entities and patient info
   */
  async getCaseWithEntities(
    supabase: SupabaseClientType,
    caseId: string,
  ): Promise<{
    case: CaseRow;
    entities: NormalizedEntities | undefined;
    patient: PatientRow | PatientRow[] | null;
    soapNotes: Database["public"]["Tables"]["soap_notes"]["Row"][] | null;
    dischargeSummaries:
      | Database["public"]["Tables"]["discharge_summaries"]["Row"][]
      | null;
    metadata: CaseMetadata;
  } | null> {
    const { data: caseData, error } = await supabase
      .from("cases")
      .select(
        `
                *,
                patient:patients(*),
                soap_notes(*),
                discharge_summaries(*)
            `,
      )
      .eq("id", caseId)
      .single();

    if (error || !caseData) {
      return null;
    }

    const metadata = (caseData.metadata as CaseMetadata | undefined) ?? {};
    const entities =
      (caseData.entity_extraction as NormalizedEntities | undefined) ??
      metadata.entities;

    const patient = Array.isArray(caseData.patient)
      ? (caseData.patient[0] ?? null)
      : (caseData.patient ?? null);

    const soapNotes = Array.isArray(caseData.soap_notes)
      ? caseData.soap_notes
      : caseData.soap_notes
        ? [caseData.soap_notes]
        : null;

    const dischargeSummaries = Array.isArray(caseData.discharge_summaries)
      ? caseData.discharge_summaries
      : caseData.discharge_summaries
        ? [caseData.discharge_summaries]
        : null;

    return {
      case: caseData,
      entities,
      patient,
      soapNotes,
      dischargeSummaries,
      metadata,
    };
  },

  /**
   * Auto-generate structured discharge summary for IDEXX Neo cases
   *
   * Called automatically when an IDEXX Neo case is imported.
   * Generates a SHORT, CONCISE, PET-OWNER FRIENDLY discharge summary.
   */
  async autoGenerateDischargeSummary(
    supabase: SupabaseClientType,
    userId: string,
    caseId: string,
    entities: NormalizedEntities,
  ): Promise<{ summaryId: string } | null> {
    try {
      // Check if discharge summary already exists for this case
      const { data: existingSummaries } = await supabase
        .from("discharge_summaries")
        .select("id")
        .eq("case_id", caseId)
        .limit(1);

      if (existingSummaries && existingSummaries.length > 0) {
        console.log(
          "[CasesService] Discharge summary already exists, skipping auto-generation",
          {
            caseId,
            existingSummaryId: existingSummaries[0]?.id,
          },
        );
        return null;
      }

      // Check if we have enough data to generate a summary
      const hasMinimumData =
        entities.patient.name &&
        (Boolean(entities.clinical.diagnoses?.length) ||
          Boolean(entities.clinical.chiefComplaint) ||
          Boolean(entities.clinical.visitReason));

      if (!hasMinimumData) {
        console.log("[CasesService] Insufficient data for auto-generation", {
          caseId,
          hasPatientName: !!entities.patient.name,
          hasDiagnoses: !!entities.clinical.diagnoses?.length,
          hasChiefComplaint: !!entities.clinical.chiefComplaint,
        });
        return null;
      }

      console.log(
        "[CasesService] Auto-generating discharge summary for IDEXX case",
        {
          caseId,
          patientName: entities.patient.name,
        },
      );

      // Generate structured discharge summary
      const { structured, plainText } =
        await generateStructuredDischargeSummaryWithRetry({
          entityExtraction: entities,
          patientData: {
            name: entities.patient.name,
            species: entities.patient.species,
            breed: entities.patient.breed,
            owner_name: entities.patient.owner.name,
          },
        });

      // Save to database
      const { data: summary, error } = await supabase
        .from("discharge_summaries")
        .insert({
          case_id: caseId,
          user_id: userId,
          content: plainText,
          structured_content: structured as unknown as Json,
        })
        .select("id")
        .single();

      if (error) {
        console.error("[CasesService] Failed to save auto-generated summary", {
          caseId,
          error: error.message,
        });
        return null;
      }

      console.log(
        "[CasesService] Successfully auto-generated discharge summary",
        {
          caseId,
          summaryId: summary.id,
          patientName: structured.patientName,
        },
      );

      return { summaryId: summary.id };
    } catch (error) {
      // Don't throw - auto-generation is optional and shouldn't block case creation
      console.error("[CasesService] Auto-generation failed", {
        caseId,
        error: error instanceof Error ? error.message : String(error),
      });
      return null;
    }
  },

  /**
   * Schedule the discharge call linked to the case
   */
  async scheduleDischargeCall(
    supabase: SupabaseClientType,
    userId: string,
    caseId: string,
    options: CaseScheduleOptions,
  ): Promise<ScheduledDischargeCall> {
    // 1. Fetch Case Data to build variables
    let caseInfo = await this.getCaseWithEntities(supabase, caseId);
    if (!caseInfo) throw new Error("Case not found");

    let entities = caseInfo.entities;

    // 1a. Enrich entities with database values (database takes priority)
    this.enrichEntitiesWithPatient(entities, caseInfo.patient);

    // 1b. Enrich with client instructions from SOAP notes or discharge summaries
    if (entities) {
      let clientInstructions: string | null = null;

      // Priority 1: SOAP notes client_instructions
      if (caseInfo.soapNotes && caseInfo.soapNotes.length > 0) {
        const latestSoapNote = caseInfo.soapNotes[0];
        if (latestSoapNote?.client_instructions) {
          clientInstructions = latestSoapNote.client_instructions;
          console.log(
            "[CasesService] Using client instructions from SOAP notes",
            {
              caseId,
              source: "soap_notes.client_instructions",
              preview: clientInstructions?.substring(0, 100) ?? "",
            },
          );
        } else if (latestSoapNote?.plan) {
          // Priority 2: SOAP notes plan
          clientInstructions = latestSoapNote.plan;
          console.log("[CasesService] Using plan from SOAP notes", {
            caseId,
            source: "soap_notes.plan",
            preview: clientInstructions?.substring(0, 100) ?? "",
          });
        }
      }

      // Priority 3: Discharge summaries content
      if (
        !clientInstructions &&
        caseInfo.dischargeSummaries &&
        caseInfo.dischargeSummaries.length > 0
      ) {
        const latestDischargeSummary = caseInfo.dischargeSummaries[0];
        if (latestDischargeSummary?.content) {
          clientInstructions = latestDischargeSummary.content;
          console.log("[CasesService] Using discharge summary content", {
            caseId,
            source: "discharge_summaries.content",
            preview: clientInstructions?.substring(0, 100) ?? "",
          });
        }
      }

      // Add to entities if found
      if (clientInstructions) {
        entities.clinical.followUpInstructions = clientInstructions;
        console.log(
          "[CasesService] Enriched entities with client instructions",
          {
            caseId,
            instructionsLength: clientInstructions.length,
          },
        );
      }
    }

    // 2. Fallback: If entities are missing or incomplete, try extracting from transcription
    if (!entities || this.isEntitiesIncomplete(entities)) {
      console.log(
        "[CasesService] Entities missing or incomplete, attempting extraction from transcription",
        {
          caseId,
          hasEntities: !!entities,
          missingFields: entities
            ? this.getMissingEntityFields(entities)
            : ["all"],
        },
      );

      // Fetch transcription text
      const { data: transcriptionData } = await supabase
        .from("transcriptions")
        .select("transcript")
        .eq("case_id", caseId)
        .order("created_at", { ascending: false })
        .limit(1)
        .maybeSingle();

      if (transcriptionData?.transcript) {
        try {
          // Extract entities from transcription
          const extractedEntities = await extractEntitiesWithRetry(
            transcriptionData.transcript,
            "transcript",
          );

          // Merge with existing entities (if any), with extracted taking precedence
          entities = entities
            ? this.mergeEntitiesForExtraction(entities, extractedEntities)
            : extractedEntities;

          // Update case metadata with enriched entities
          const updatedMetadata: CaseMetadata = {
            ...caseInfo.metadata,
            entities,
          };

          await supabase
            .from("cases")
            .update({ metadata: updatedMetadata as Json })
            .eq("id", caseId);

          console.log(
            "[CasesService] Successfully extracted and merged entities from transcription",
            {
              caseId,
              extractedFields: this.getExtractedFields(extractedEntities),
            },
          );

          // Refresh case info with updated entities
          caseInfo = await this.getCaseWithEntities(supabase, caseId);
          if (!caseInfo) throw new Error("Case not found after update");
          entities = caseInfo.entities;

          // Re-apply database enrichment after re-fetch
          // This ensures database values take priority even after transcription extraction
          this.enrichEntitiesWithPatient(entities, caseInfo.patient);
        } catch (extractionError) {
          console.error(
            "[CasesService] Failed to extract entities from transcription",
            {
              caseId,
              error: extractionError,
            },
          );
          // Continue with existing entities (or throw if none)
          if (!entities) {
            throw new Error(
              "Case has no entities and extraction from transcription failed",
            );
          }
        }
      } else {
        // No transcription available
        if (!entities) {
          throw new Error(
            "Case has no entities and no transcription available for extraction",
          );
        }
        console.warn(
          "[CasesService] Entities incomplete but no transcription found",
          {
            caseId,
            missingFields: this.getMissingEntityFields(entities),
          },
        );
      }
    }

    if (!entities) throw new Error("Case has no entities");

    // 2. Extract AI-extracted variables (species, breed, age, diagnoses, etc.)
    const extractedVars = extractVapiVariablesFromEntities(entities);

    // 2a. Generate AI call intelligence (hyper-specific questions for this case)
    // This replaces generic knowledge base questions with case-specific ones
    let aiIntelligence: AIGeneratedCallIntelligence | null = null;
    try {
      console.log("[CasesService] Generating AI call intelligence", {
        caseId,
        petName: entities.patient.name,
        diagnosis: entities.clinical.diagnoses?.[0],
      });

      const intelligence = await generateCallIntelligenceFromEntities(entities);
      aiIntelligence = {
        caseContextSummary: intelligence.caseContextSummary,
        assessmentQuestions: intelligence.assessmentQuestions,
        warningSignsToMonitor: intelligence.warningSignsToMonitor,
        normalExpectations: intelligence.normalExpectations,
        emergencyCriteria: intelligence.emergencyCriteria,
        shouldAskClinicalQuestions: intelligence.shouldAskClinicalQuestions,
        callApproach: intelligence.callApproach,
        confidence: intelligence.confidence,
      };

      console.log("[CasesService] AI call intelligence generated", {
        caseId,
        questionCount: intelligence.assessmentQuestions?.length ?? 0,
        callApproach: intelligence.callApproach,
        shouldAskQuestions: intelligence.shouldAskClinicalQuestions,
        confidence: intelligence.confidence,
      });
    } catch (aiError) {
      // Non-blocking: fall back to static knowledge base
      console.warn(
        "[CasesService] Failed to generate AI call intelligence, using static KB",
        {
          caseId,
          error: aiError instanceof Error ? aiError.message : String(aiError),
        },
      );
    }

    // 3. Build Dynamic Variables with knowledge base integration
    // Use extractFirstName to get only the first word of the pet name
    // (many vet systems store "FirstName LastName" but we only want first name for calls)
    const variablesResult = buildDynamicVariables({
      baseVariables: {
        clinicName: options.clinicName ?? "Your Clinic",
        agentName: options.agentName ?? "Sarah",
        petName: extractFirstName(entities.patient.name),
        ownerName: entities.patient.owner.name,
        // Keep date phrasing generic to avoid incorrect relative day mentions
        appointmentDate: "recent visit",
        callType: "discharge",
        clinicPhone: options.clinicPhone ?? "",
        emergencyPhone: options.emergencyPhone ?? options.clinicPhone ?? "",
        dischargeSummary:
          options.summaryContent ?? generateSummaryFromEntities(entities),

        medications: entities.clinical.medications
          ?.map((m) => `${m.name} ${m.dosage ?? ""} ${m.frequency ?? ""}`)
          .join(", "),
        vaccinations: entities.clinical.vaccinations
          ?.map((v) => v.name)
          .join(", "),
        nextSteps: entities.clinical.followUpInstructions,

        // Include species/breed/age if available from entities
        // Note: petSpecies is limited to "dog" | "cat" | "other" for buildDynamicVariables
        // but extractedVars will include full patient_species (dog, cat, bird, rabbit, etc.)
        petSpecies:
          entities.patient.species === "dog" ||
          entities.patient.species === "cat"
            ? entities.patient.species
            : entities.patient.species
              ? "other"
              : undefined,
        petAge: entities.patient.age
          ? (() => {
              const num = parseFloat(
                entities.patient.age.replace(/[^0-9.]/g, ""),
              );
              return isNaN(num) ? undefined : num;
            })()
          : undefined,
        petWeight: entities.patient.weight
          ? (() => {
              const num = parseFloat(
                entities.patient.weight.replace(/[^0-9.]/g, ""),
              );
              return isNaN(num) ? undefined : num;
            })()
          : undefined,
      },
      strict: false,
      useDefaults: true,
      // Pass AI-generated intelligence (preferred over static KB)
      aiGeneratedIntelligence: aiIntelligence ?? undefined,
    });

    // 4. Merge extracted variables with buildDynamicVariables result
    // Extracted vars (snake_case) are merged first, then buildDynamicVariables vars (camelCase)
    // are normalized and merged, with manual vars taking precedence
    const mergedVariables = {
      ...extractedVars, // Already snake_case (patient_species, patient_breed, etc.)
      ...normalizeVariablesToSnakeCase(
        variablesResult.variables as unknown as Record<string, unknown>,
      ), // Convert camelCase to snake_case
    };

    // 3. Insert Scheduled Call
    // Get clinic-specific VAPI configuration (falls back to env vars if not configured)
    const clinicVapiConfig = await getClinicVapiConfigByUserId(
      userId,
      supabase,
    );
    const assistantId =
      options.assistantId ?? clinicVapiConfig.outboundAssistantId;
    const phoneNumberId =
      options.phoneNumberId ?? clinicVapiConfig.phoneNumberId;

    console.log("[CasesService] Using VAPI config", {
      source: clinicVapiConfig.source,
      clinicName: clinicVapiConfig.clinicName,
      hasAssistantId: !!assistantId,
      hasPhoneNumberId: !!phoneNumberId,
    });

    // Get customer phone (with test mode support)
    let customerPhone = entities.patient.owner.phone ?? "";

    // Check if test mode is enabled and get schedule override
    const { data: userSettings } = await supabase
      .from("users")
      .select(
        "test_mode_enabled, test_contact_phone, test_contact_name, default_schedule_delay_minutes",
      )
      .eq("id", userId)
      .single();

    const testModeEnabled = userSettings?.test_mode_enabled ?? false;
    const defaultScheduleDelayMinutes =
      userSettings?.default_schedule_delay_minutes;

    if (testModeEnabled) {
      if (!userSettings?.test_contact_phone) {
        throw new Error(
          "Test mode is enabled but test contact phone is not configured",
        );
      }

      console.log(
        "[CasesService] Test mode enabled - redirecting call to test contact",
        {
          originalPhone: customerPhone,
          testPhone: userSettings.test_contact_phone,
          testContactName: userSettings.test_contact_name,
        },
      );

      customerPhone = userSettings.test_contact_phone;
    } else if (!customerPhone) {
      throw new Error("Patient phone number is required to schedule call");
    }

    // Normalize phone number to E.164 format (+1XXXXXXXXXX for US numbers)
    const normalizedPhone = normalizeToE164(customerPhone);
    if (!normalizedPhone) {
      throw new Error(`Invalid phone number format: ${customerPhone}`);
    }
    customerPhone = normalizedPhone;

    // Determine scheduled time using server time
    // Always use server time to avoid timezone and clock drift issues
    const serverNow = new Date();
    let scheduledAt: Date;

    if (options.scheduledAt) {
      // Validate that provided scheduled time is in the future
      if (options.scheduledAt <= serverNow) {
        throw new Error(
          `Scheduled time must be in the future. Provided: ${options.scheduledAt.toISOString()}, Server now: ${serverNow.toISOString()}`,
        );
      }
      scheduledAt = options.scheduledAt;
    } else {
      // Use user's default schedule delay override if set, otherwise use system defaults
      let delayMinutes: number;
      if (
        defaultScheduleDelayMinutes !== null &&
        defaultScheduleDelayMinutes !== undefined
      ) {
        delayMinutes = defaultScheduleDelayMinutes;
        console.log("[CasesService] Using user override for schedule delay", {
          delayMinutes,
          serverNow: serverNow.toISOString(),
        });
      } else if (testModeEnabled) {
        // Test mode: schedule for 1 minute from server time
        delayMinutes = 1;
      } else {
        // Normal mode: schedule for 2 minutes from server time
        delayMinutes = 2;
      }

      scheduledAt = new Date(serverNow.getTime() + delayMinutes * 60 * 1000);
      console.log("[CasesService] Scheduling call", {
        delayMinutes,
        testModeEnabled,
        serverNow: serverNow.toISOString(),
        scheduledAt: scheduledAt.toISOString(),
      });
    }

    // Check if a call already exists for this case
    // If it exists, update it instead of creating a new one to persist status
    const { data: existingCall } = await supabase
      .from("scheduled_discharge_calls")
      .select("id, status, vapi_call_id, scheduled_for")
      .eq("case_id", caseId)
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    let scheduledCall: ScheduledDischargeCall;

    if (existingCall) {
      // Update existing call - preserve status if call is already in progress/completed
      // Only update to "queued" if status is null or if explicitly resetting
      const currentStatus = existingCall.status;
      const shouldPreserveStatus =
        currentStatus &&
        (currentStatus === "in_progress" ||
          currentStatus === "ringing" ||
          currentStatus === "completed");

      const updateData: Partial<ScheduledCallRow> = {
        assistant_id: assistantId ?? "",
        phone_number_id: phoneNumberId ?? "",
        customer_phone: customerPhone,
        user_id: userId,
        scheduled_for: scheduledAt.toISOString(),
        status: shouldPreserveStatus
          ? (currentStatus as
              | "queued"
              | "in_progress"
              | "ringing"
              | "completed"
              | "failed"
              | "canceled")
          : ("queued" as const),
        dynamic_variables: mergedVariables as Json,
        metadata: {
          notes: options.notes,
          retry_count: 0,
          max_retries: 3,
        } as Json,
      };

      const { data: updatedCall, error: updateError } = await supabase
        .from("scheduled_discharge_calls")
        .update(updateData)
        .eq("id", existingCall.id)
        .select()
        .single();

      if (updateError || !updatedCall) {
        throw new Error(
          `Failed to update existing call: ${
            updateError?.message ?? "Unknown error"
          }`,
        );
      }

      scheduledCall = updatedCall as ScheduledDischargeCall;

      console.log("[CasesService] Updated existing call for case", {
        caseId,
        callId: scheduledCall.id,
        preservedStatus: shouldPreserveStatus,
        status: scheduledCall.status,
      });

      // If updating an existing call, only reschedule QStash if the scheduled time changed
      // or if there's no existing QStash message ID
      const existingMetadata = scheduledCall.metadata;
      const hasExistingQStashId = !!existingMetadata?.qstash_message_id;
      const scheduledTimeChanged =
        existingCall.scheduled_for !== scheduledAt.toISOString();

      if (!hasExistingQStashId || scheduledTimeChanged) {
        // Reschedule QStash for the updated time
        const qstashMessageId = await scheduleCallExecution(
          scheduledCall.id,
          scheduledAt,
        );

        const updatedMetadata: ScheduledCallMetadata = {
          ...existingMetadata,
          qstash_message_id: qstashMessageId,
        };

        const { error: updateError } = await supabase
          .from("scheduled_discharge_calls")
          .update({
            metadata: updatedMetadata as Json,
          })
          .eq("id", scheduledCall.id);

        if (updateError) {
          console.error(
            "[CasesService] Error updating QStash message ID:",
            updateError,
          );
          // Don't throw - call was updated successfully
        }
      }
    } else {
      // Create new call
      const scheduledCallInsert: ScheduledCallInsert = {
        user_id: userId,
        case_id: caseId,
        assistant_id: assistantId ?? "",
        phone_number_id: phoneNumberId ?? "",
        customer_phone: customerPhone,
        scheduled_for: scheduledAt.toISOString(),
        status: "queued" as const,
        dynamic_variables: mergedVariables as Json, // Use merged variables with AI-extracted data
        metadata: {
          notes: options.notes,
          retry_count: 0,
          max_retries: 3,
        } as Json,
      };

      const { data: newCall, error } = await supabase
        .from("scheduled_discharge_calls")
        .insert(scheduledCallInsert)
        .select()
        .single();

      if (error || !newCall) {
        throw new Error(
          `Failed to schedule call: ${error?.message ?? "Unknown error"}`,
        );
      }

      scheduledCall = newCall as ScheduledDischargeCall;

      // 4. Trigger QStash for new call
      const qstashMessageId = await scheduleCallExecution(
        scheduledCall.id,
        scheduledAt,
      );

      // Update with QStash ID
      const updatedMetadata: ScheduledCallMetadata = {
        ...(scheduledCall.metadata ?? {}),
        qstash_message_id: qstashMessageId,
      };

      const { error: updateError } = await supabase
        .from("scheduled_discharge_calls")
        .update({
          metadata: updatedMetadata as Json,
        })
        .eq("id", scheduledCall.id);

      if (updateError) {
        console.error(
          "[CasesService] Error updating QStash message ID:",
          updateError,
        );
        // Don't throw - call was scheduled successfully
      }
    }

    return scheduledCall;
  },

  /**
   * Check if entities are incomplete (missing critical fields like species, breed, age)
   */
  isEntitiesIncomplete(entities: NormalizedEntities): boolean {
    const missingFields = this.getMissingEntityFields(entities);
    // Consider incomplete if missing species, breed, age, or weight
    return (
      missingFields.includes("species") ||
      missingFields.includes("breed") ||
      missingFields.includes("age") ||
      missingFields.includes("weight")
    );
  },

  /**
   * Get list of missing entity fields
   */
  getMissingEntityFields(entities: NormalizedEntities): string[] {
    const missing: string[] = [];
    if (!entities.patient.species || entities.patient.species === "unknown") {
      missing.push("species");
    }
    if (!entities.patient.breed) {
      missing.push("breed");
    }
    if (!entities.patient.age) {
      missing.push("age");
    }
    if (!entities.patient.weight) {
      missing.push("weight");
    }
    return missing;
  },

  /**
   * Enrich entities with database patient values
   *
   * Database values take priority over AI-extracted metadata values.
   * This ensures accurate patient information even when AI extraction fails.
   *
   * @param entities - The entities object to enrich (modified in place)
   * @param patient - Patient record from database (single or array)
   */
  enrichEntitiesWithPatient(
    entities: NormalizedEntities | undefined,
    patient: PatientRow | PatientRow[] | null,
  ): void {
    if (!entities || !patient) {
      return;
    }

    // Handle both single patient and array of patients
    const patientData = Array.isArray(patient) ? patient[0] : patient;

    if (!patientData) {
      return;
    }

    // Enrich patient name from database (database takes priority)
    if (patientData.name && patientData.name.trim() !== "") {
      entities.patient.name = patientData.name;
    }

    // Enrich patient demographics from database
    if (patientData.species) {
      entities.patient.species =
        patientData.species as NormalizedEntities["patient"]["species"];
    }
    if (patientData.breed) {
      entities.patient.breed = patientData.breed;
    }
    if (patientData.sex) {
      entities.patient.sex =
        patientData.sex as NormalizedEntities["patient"]["sex"];
    }
    if (patientData.weight_kg) {
      entities.patient.weight = `${patientData.weight_kg} kg`;
    }

    // Enrich owner information from database
    if (patientData.owner_name) {
      entities.patient.owner.name = patientData.owner_name;
    }
    if (patientData.owner_phone) {
      entities.patient.owner.phone = patientData.owner_phone;
    }
    if (patientData.owner_email) {
      entities.patient.owner.email = patientData.owner_email;
    }

    console.log(
      "[CasesService] Enriched entities with patient database values",
      {
        enrichedFields: {
          name: patientData.name,
          species: patientData.species,
          breed: patientData.breed,
          sex: patientData.sex,
          weight: patientData.weight_kg,
          ownerName: patientData.owner_name,
          ownerPhone: patientData.owner_phone,
        },
      },
    );
  },

  /**
   * Get list of successfully extracted fields (for logging)
   */
  getExtractedFields(entities: NormalizedEntities): string[] {
    const extracted: string[] = [];
    if (entities.patient.species && entities.patient.species !== "unknown") {
      extracted.push("species");
    }
    if (entities.patient.breed) {
      extracted.push("breed");
    }
    if (entities.patient.age) {
      extracted.push("age");
    }
    if (entities.patient.weight) {
      extracted.push("weight");
    }
    return extracted;
  },

  /**
   * Merge two entity sets, with extractedEntities taking precedence for missing fields
   * Used when re-extracting from transcription to fill in missing data
   */
  mergeEntitiesForExtraction(
    existing: NormalizedEntities,
    extracted: NormalizedEntities,
  ): NormalizedEntities {
    return {
      ...existing,
      patient: {
        ...existing.patient,
        // Use extracted values if existing is missing/unknown
        species:
          existing.patient.species && existing.patient.species !== "unknown"
            ? existing.patient.species
            : (extracted.patient.species ?? existing.patient.species),
        breed: existing.patient.breed ?? extracted.patient.breed,
        age: existing.patient.age ?? extracted.patient.age,
        sex:
          existing.patient.sex && existing.patient.sex !== "unknown"
            ? existing.patient.sex
            : (extracted.patient.sex ?? existing.patient.sex),
        weight: existing.patient.weight ?? extracted.patient.weight,
        owner: {
          ...existing.patient.owner,
          name: existing.patient.owner.name ?? extracted.patient.owner.name,
          phone: existing.patient.owner.phone ?? extracted.patient.owner.phone,
          email: existing.patient.owner.email ?? extracted.patient.owner.email,
        },
      },
      clinical: {
        ...existing.clinical,
        // Merge clinical data, preferring extracted for missing fields
        chiefComplaint:
          existing.clinical.chiefComplaint ?? extracted.clinical.chiefComplaint,
        visitReason:
          existing.clinical.visitReason ?? extracted.clinical.visitReason,
        presentingSymptoms:
          (existing.clinical.presentingSymptoms?.length ?? 0 > 0)
            ? existing.clinical.presentingSymptoms
            : extracted.clinical.presentingSymptoms,
        diagnoses:
          (existing.clinical.diagnoses?.length ?? 0 > 0)
            ? existing.clinical.diagnoses
            : extracted.clinical.diagnoses,
        medications:
          (existing.clinical.medications?.length ?? 0 > 0)
            ? existing.clinical.medications
            : extracted.clinical.medications,
        followUpInstructions:
          existing.clinical.followUpInstructions ??
          extracted.clinical.followUpInstructions,
        recheckRequired:
          existing.clinical.recheckRequired ??
          extracted.clinical.recheckRequired,
      },
      // Keep existing caseType and confidence, but update extractedAt
      caseType: existing.caseType ?? extracted.caseType,
      confidence: existing.confidence,
      extractedAt: extracted.extractedAt ?? existing.extractedAt,
      warnings: [
        ...(existing.warnings ?? []),
        ...(extracted.warnings ?? []),
      ].filter((w, i, arr) => arr.indexOf(w) === i), // Remove duplicates
    };
  },

  /**
   * Merge logic for entities (used during case creation/update)
   */
  mergeEntities(
    current: NormalizedEntities | undefined,
    incoming: NormalizedEntities,
  ): NormalizedEntities {
    if (!current) return incoming;
    return incoming;
  },
};

// --- Helpers ---

function mapCaseTypeToDb(
  type: string,
): Database["public"]["Enums"]["CaseType"] {
  // DB: "checkup" | "emergency" | "surgery" | "follow_up"
  // Note: euthanasia maps to follow_up for DB, but discharge blocking happens at entity level
  const map: Record<string, Database["public"]["Enums"]["CaseType"]> = {
    checkup: "checkup",
    vaccination: "checkup",
    consultation: "checkup",
    exam: "checkup",
    emergency: "emergency",
    surgery: "surgery",
    dental: "surgery",
    follow_up: "follow_up",
    diagnostic: "follow_up",
    euthanasia: "follow_up", // DB doesn't have euthanasia type, but we check entities.caseType for discharge blocking
    other: "follow_up",
    unknown: "checkup",
  };
  return map[type] ?? "checkup";
}

function mapIdexxToEntities(data: Record<string, unknown>): NormalizedEntities {
  const petName = typeof data.pet_name === "string" ? data.pet_name : "Unknown";

  // Map to valid species enum values
  const validSpecies = [
    "dog",
    "cat",
    "bird",
    "rabbit",
    "other",
    "unknown",
  ] as const;
  type ValidSpecies = (typeof validSpecies)[number];
  const rawSpecies =
    typeof data.species === "string" ? data.species.toLowerCase() : "unknown";
  const species: ValidSpecies = validSpecies.includes(
    rawSpecies as ValidSpecies,
  )
    ? (rawSpecies as ValidSpecies)
    : "unknown";

  const clientFirstName =
    typeof data.client_first_name === "string" ? data.client_first_name : "";
  const clientLastName =
    typeof data.client_last_name === "string" ? data.client_last_name : "";
  const ownerName =
    typeof data.owner_name === "string" ? data.owner_name : "Unknown";
  const phone =
    typeof data.phone_number === "string"
      ? data.phone_number
      : typeof data.mobile_number === "string"
        ? data.mobile_number
        : undefined;
  const email = typeof data.email === "string" ? data.email : undefined;

  // Parse billing data for AI context
  const acceptedItems = parseBillingString(
    data.products_services as string | undefined,
    false,
  );
  const declinedItems = parseBillingString(
    data.declined_products_services as string | undefined,
    true,
  );

  // Extract product names for clinical entities
  const productsServicesProvided =
    acceptedItems.length > 0
      ? acceptedItems.map((item) =>
          item.quantity > 1
            ? `${item.productService} (Qty: ${item.quantity})`
            : item.productService,
        )
      : undefined;

  const productsServicesDeclined =
    declinedItems.length > 0
      ? declinedItems.map((item) =>
          item.quantity > 1
            ? `${item.productService} (Qty: ${item.quantity})`
            : item.productService,
        )
      : undefined;

  return {
    patient: {
      name: petName,
      species: species,
      owner: {
        name:
          clientFirstName && clientLastName
            ? `${clientFirstName} ${clientLastName}`
            : ownerName,
        phone: phone,
        email: email,
      },
    },
    clinical: {
      medications: [],
      diagnoses: [],
      // Include billing data for AI context (discharge summaries, calls)
      productsServicesProvided,
      productsServicesDeclined,
    },
    caseType: "checkup",
    confidence: { overall: 0.5, patient: 0.5, clinical: 0.5 },
    extractedAt: new Date().toISOString(),
  };
}

function parseWeight(weightStr?: string): number | null {
  if (!weightStr) return null;
  const num = parseFloat(weightStr);
  return isNaN(num) ? null : num;
}

function generateSummaryFromEntities(entities: NormalizedEntities): string {
  const parts = [];
  if (entities.clinical.diagnoses?.length) {
    parts.push(`Diagnoses: ${entities.clinical.diagnoses.join(", ")}.`);
  }
  if (entities.clinical.medications?.length) {
    const medList = entities.clinical.medications
      .map((m) => `${m.name} (${m.dosage ?? ""}, ${m.frequency ?? ""})`)
      .join("; ");
    parts.push(`Medications: ${medList}.`);
  }
  if (entities.clinical.followUpInstructions) {
    parts.push(`Instructions: ${entities.clinical.followUpInstructions}`);
  }
  return parts.join(" ");
}
