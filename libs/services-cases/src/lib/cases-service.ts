import { type NormalizedEntities } from "@odis-ai/validators";
import { scheduleCallExecution } from "@odis-ai/qstash/client";
import type { AIGeneratedCallIntelligence } from "@odis-ai/vapi/types";
import { normalizeToE164 } from "@odis-ai/utils/phone";
import { getClinicVapiConfigByUserId } from "@odis-ai/clinics/vapi-config";
import type { ICallExecutor } from "@odis-ai/services-shared";

// Type imports
import type { Database, Json } from "@odis-ai/types";
import type { SupabaseClientType } from "@odis-ai/types/supabase";
import type {
  CaseScheduleOptions,
  IngestPayload,
  ScheduledCallMetadata,
  ScheduledDischargeCall,
} from "@odis-ai/types/services";
import type { CaseMetadata, CaseMetadataJson } from "@odis-ai/types/case";
import {
  buildIdexxConsultationData,
  parseBillingString,
} from "@odis-ai/types/idexx";

// Re-export types for convenience
export type { CaseScheduleOptions, IngestPayload, ScheduledDischargeCall };

/* ========================================
   Type Aliases
   ======================================== */

/**
 * Database table row types
 */
type CaseRow = Database["public"]["Tables"]["cases"]["Row"];
type CaseInsert = Database["public"]["Tables"]["cases"]["Insert"];
type CaseUpdate = Database["public"]["Tables"]["cases"]["Update"];
type ScheduledCallRow =
  Database["public"]["Tables"]["scheduled_discharge_calls"]["Row"];
type ScheduledCallInsert =
  Database["public"]["Tables"]["scheduled_discharge_calls"]["Insert"];

type PatientRow = Database["public"]["Tables"]["patients"]["Row"];
type PatientInsert = Database["public"]["Tables"]["patients"]["Insert"];

type TranscriptionInsert =
  Database["public"]["Tables"]["transcriptions"]["Insert"];

/* ========================================
   Service Implementation
   ======================================== */

export const CasesService = {
  /**
   * Main entry point for ingesting case data
   */
  async ingest(
    supabase: SupabaseClientType,
    userId: string,
    payload: IngestPayload,
  ): Promise<{
    caseId: string;
    entities: NormalizedEntities;
    scheduledCall: ScheduledDischargeCall | null;
  }> {
    let entities: NormalizedEntities | null = null;
    let rawIdexxData: Record<string, unknown> | null = null;
    let transcriptionText: string | null = null;

    // 1. Normalize Data
    if (payload.mode === "text") {
      transcriptionText = payload.text;
      // Run AI Normalization (dynamic import to avoid lazy-load constraint)
      const { extractEntitiesWithRetry } =
        await import("@odis-ai/ai/normalize-scribe");
      entities = await extractEntitiesWithRetry(
        payload.text,
        payload.options?.inputType,
      );
    } else {
      // Mode: structured (IDEXX)
      rawIdexxData = payload.data;

      // For IDEXX sources, try AI extraction from consultation notes first
      // This provides much richer entity extraction than basic field mapping
      if (
        payload.source === "idexx_extension" ||
        payload.source === "idexx_neo"
      ) {
        const aiExtractedEntities =
          await this.extractEntitiesFromIdexx(rawIdexxData);

        if (aiExtractedEntities) {
          entities = aiExtractedEntities;
          console.log(
            "[CasesService] Used AI extraction from IDEXX consultation notes",
            {
              source: payload.source,
              patientName: entities.patient.name,
              confidence: entities.confidence?.overall,
            },
          );
        } else {
          // Fall back to basic mapping if AI extraction fails or has insufficient data
          console.log(
            "[CasesService] Falling back to basic IDEXX field mapping",
            {
              source: payload.source,
            },
          );
          if (payload.data.patient && payload.data.clinical) {
            entities = payload.data as NormalizedEntities;
          } else {
            entities = mapIdexxToEntities(payload.data);
          }
        }
      } else {
        // Non-IDEXX structured data - use existing logic
        if (payload.data.patient && payload.data.clinical) {
          entities = payload.data as NormalizedEntities;
        } else {
          entities = mapIdexxToEntities(payload.data);
        }
      }
    }

    if (!entities) {
      throw new Error("Failed to extract entities from payload");
    }

    // 2. Find or Create Case (Smart Merge)
    const caseResult = await this.createOrUpdateCase(
      supabase,
      userId,
      entities,
      {
        rawIdexxData,
        transcriptionText,
        source: payload.source,
      },
    );

    // 3. For IDEXX sources: Auto-generate discharge summary AND call intelligence
    if (
      payload.source === "idexx_extension" ||
      payload.source === "idexx_neo"
    ) {
      // 3a. Auto-generate discharge summary
      await this.autoGenerateDischargeSummary(
        supabase,
        userId,
        caseResult.caseId,
        caseResult.entities,
      );

      // 3b. Pre-generate call intelligence for faster call scheduling
      await this.generateAndStoreCallIntelligence(
        supabase,
        caseResult.caseId,
        caseResult.entities,
      );
    }

    // 4. Auto-Schedule if requested
    let scheduledCall = null;
    if (payload.options?.autoSchedule) {
      const scheduledAt = new Date(); // Immediate/Queued

      scheduledCall = await this.scheduleDischargeCall(
        supabase,
        userId,
        caseResult.caseId,
        {
          scheduledAt,
        },
      );
    }

    return {
      caseId: caseResult.caseId,
      entities: caseResult.entities,
      scheduledCall,
    };
  },

  /**
   * Find existing case or create new one, merging data
   */
  async createOrUpdateCase(
    supabase: SupabaseClientType,
    userId: string,
    entities: NormalizedEntities,
    context: {
      rawIdexxData?: Record<string, unknown> | null;
      transcriptionText?: string | null;
      source: string;
    },
  ): Promise<{
    caseId: string;
    entities: NormalizedEntities;
  }> {
    let caseId: string | null = null;

    // 1. FIRST: Check by external_id (IDEXX appointment ID) - exact match, highest priority
    // This prevents duplicate cases from being created for the same IDEXX appointment
    const idexxAppointmentId =
      (context.rawIdexxData?.appointmentId as string | undefined) ??
      (context.rawIdexxData?.id as string | undefined);

    if (idexxAppointmentId && context.source === "idexx_extension") {
      const externalId = `idexx-appt-${idexxAppointmentId}`;
      const { data: existingByExtId, error: extIdError } = await supabase
        .from("cases")
        .select("id")
        .eq("external_id", externalId)
        .eq("user_id", userId)
        .maybeSingle();

      if (extIdError) {
        console.error("[CasesService] Error checking external_id:", extIdError);
      }

      if (existingByExtId) {
        console.log("[CasesService] Found existing case by external_id", {
          externalId,
          caseId: existingByExtId.id,
        });
        caseId = existingByExtId.id;
      }
    }

    // 2. FALLBACK: Try to find existing case by patient name and owner (case-insensitive)
    // Only if we didn't find by external_id
    if (!caseId) {
      // Discharges can be sent anytime after a case is created, so we look for
      // cases within a reasonable window (90 days) that are ongoing or completed
      const ninetyDaysAgo = new Date();
      ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
      ninetyDaysAgo.setHours(0, 0, 0, 0);

      // First find matching patients (case-insensitive)
      const { data: matchingPatients, error: patientSearchError } =
        await supabase
          .from("patients")
          .select("case_id")
          .eq("user_id", userId)
          .ilike("name", entities.patient.name)
          .ilike("owner_name", entities.patient.owner.name ?? "")
          .not("case_id", "is", null);

      if (patientSearchError) {
        console.error(
          "[CasesService] Error searching for patients:",
          patientSearchError,
        );
      }

      // If we found matching patients, get their cases
      if (matchingPatients && matchingPatients.length > 0) {
        const caseIds = matchingPatients
          .map((p) => p.case_id)
          .filter((id): id is string => id !== null);

        if (caseIds.length > 0) {
          const { data: existingCases, error: caseSearchError } = await supabase
            .from("cases")
            .select("id, status, created_at")
            .in("id", caseIds)
            .in("status", ["ongoing", "completed"])
            .gte("created_at", ninetyDaysAgo.toISOString())
            .order("created_at", { ascending: false })
            .limit(1);

          if (caseSearchError) {
            console.error(
              "[CasesService] Error searching for cases:",
              caseSearchError,
            );
          }

          if (existingCases && existingCases.length > 0) {
            const match = existingCases[0];
            if (match) {
              console.log(
                "[CasesService] Found existing case by patient/owner name",
                {
                  patientName: entities.patient.name,
                  ownerName: entities.patient.owner.name,
                  caseId: match.id,
                },
              );
              caseId = match.id;
            }
          }
        }
      }
    }

    if (caseId) {
      // Update Existing Case (Merge)
      const { data: currentCase, error: fetchError } = await supabase
        .from("cases")
        .select("metadata")
        .eq("id", caseId)
        .single();

      if (fetchError) {
        throw new Error(`Failed to fetch existing case: ${fetchError.message}`);
      }

      const currentMetadata =
        (currentCase?.metadata as CaseMetadata | undefined) ?? {};
      const currentEntities = currentMetadata.entities;

      const mergedEntities = this.mergeEntities(currentEntities, entities);

      // Build structured IDEXX metadata with raw data and parsed consultation
      const newIdexx = context.rawIdexxData
        ? {
            raw: context.rawIdexxData,
            consultation: buildIdexxConsultationData(context.rawIdexxData),
          }
        : (currentMetadata.idexx ?? null);

      // Parse scheduled_at from IDEXX appointment data (if available and not already set)
      const scheduledAt = parseScheduledAt(context.rawIdexxData);

      const updateData: CaseUpdate = {
        // Save entities to dedicated column for faster access
        entity_extraction: mergedEntities as unknown as Json,
        metadata: {
          ...currentMetadata,
          entities: mergedEntities,
          idexx: newIdexx,
          last_updated_by: context.source,
        } as CaseMetadata as CaseMetadataJson,
        updated_at: new Date().toISOString(),
        // Only update scheduled_at if we have a new value (don't overwrite existing)
        ...(scheduledAt ? { scheduled_at: scheduledAt } : {}),
      };

      const { error: updateError } = await supabase
        .from("cases")
        .update(updateData)
        .eq("id", caseId);

      if (updateError) {
        throw new Error(`Failed to update case: ${updateError.message}`);
      }
    } else {
      // Create New Case
      // Generate external_id for IDEXX cases to enable future deduplication
      const idexxAppointmentId =
        (context.rawIdexxData?.appointmentId as string | undefined) ??
        (context.rawIdexxData?.id as string | undefined);
      const externalId =
        context.source === "idexx_extension" && idexxAppointmentId
          ? `idexx-appt-${idexxAppointmentId}`
          : null;

      // Build structured IDEXX metadata with raw data and parsed consultation
      const idexxMetadata = context.rawIdexxData
        ? {
            raw: context.rawIdexxData,
            consultation: buildIdexxConsultationData(context.rawIdexxData),
          }
        : null;

      // Parse scheduled_at from IDEXX appointment data
      const scheduledAt = parseScheduledAt(context.rawIdexxData);

      const caseInsert: CaseInsert = {
        user_id: userId,
        status: "ongoing",
        type: mapCaseTypeToDb(entities.caseType),
        source: context.source,
        external_id: externalId,
        scheduled_at: scheduledAt,
        // Save entities to dedicated column for faster access
        entity_extraction: entities as unknown as Json,
        metadata: {
          entities: entities,
          idexx: idexxMetadata,
        } as CaseMetadata as CaseMetadataJson,
      };

      const { data: newCase, error: caseError } = await supabase
        .from("cases")
        .insert(caseInsert)
        .select()
        .single();

      if (caseError || !newCase) {
        throw new Error(
          `Failed to create case: ${caseError?.message ?? "Unknown error"}`,
        );
      }
      caseId = newCase.id;

      console.log("[CasesService] Created new case", {
        caseId,
        externalId,
        source: context.source,
      });

      // Patient Deduplication: Find existing patient or create new one
      // First, try to find an existing patient with matching name and owner (case-insensitive)
      const { data: existingPatient, error: patientSearchError } =
        await supabase
          .from("patients")
          .select("id, name, owner_name")
          .eq("user_id", userId)
          .ilike("name", entities.patient.name)
          .ilike("owner_name", entities.patient.owner.name ?? "")
          .order("created_at", { ascending: false })
          .limit(1)
          .maybeSingle();

      if (patientSearchError) {
        console.error(
          "[CasesService] Error searching for existing patient:",
          patientSearchError,
        );
      }

      if (existingPatient) {
        // Reuse existing patient - update their case_id to link to this new case
        // Also update any new information we have
        const { error: updatePatientError } = await supabase
          .from("patients")
          .update({
            case_id: caseId,
            // Update with any new/better data from entities
            species: entities.patient.species ?? undefined,
            breed: entities.patient.breed ?? undefined,
            sex: entities.patient.sex ?? undefined,
            weight_kg: parseWeight(entities.patient.weight) ?? undefined,
            owner_phone: entities.patient.owner.phone ?? undefined,
            owner_email: entities.patient.owner.email ?? undefined,
            updated_at: new Date().toISOString(),
          })
          .eq("id", existingPatient.id);

        if (updatePatientError) {
          console.error(
            "[CasesService] Error updating existing patient:",
            updatePatientError,
          );
        } else {
          console.log("[CasesService] Reused existing patient", {
            patientId: existingPatient.id,
            patientName: existingPatient.name,
            caseId,
          });
        }
      } else {
        // Create new patient record
        const patientInsert: PatientInsert = {
          user_id: userId,
          case_id: caseId,
          name: entities.patient.name,
          species: entities.patient.species ?? null,
          breed: entities.patient.breed ?? null,
          sex: entities.patient.sex ?? null,
          weight_kg: parseWeight(entities.patient.weight),
          owner_name: entities.patient.owner.name ?? null,
          owner_phone: entities.patient.owner.phone ?? null,
          owner_email: entities.patient.owner.email ?? null,
        };

        const { data: newPatient, error: patientError } = await supabase
          .from("patients")
          .insert(patientInsert)
          .select()
          .single();

        if (patientError) {
          console.error("[CasesService] Error creating patient:", patientError);
          // Don't throw - case was created successfully, patient is optional
        } else if (newPatient) {
          console.log("[CasesService] Created new patient", {
            patientId: newPatient.id,
            patientName: newPatient.name,
            caseId,
          });
        }
      }
    }

    // Handle Transcription
    if (context.transcriptionText && caseId) {
      const transcriptionInsert: TranscriptionInsert = {
        case_id: caseId,
        user_id: userId,
        transcript: context.transcriptionText,
        processing_status: "completed",
      };

      const { error: transcriptionError } = await supabase
        .from("transcriptions")
        .insert(transcriptionInsert);

      if (transcriptionError) {
        console.error(
          "[CasesService] Error creating transcription:",
          transcriptionError,
        );
        // Don't throw - transcription is optional
      }
    }

    // TypeScript doesn't know caseId is guaranteed to be set, but logically it always is
    // (either from existing case or newly created case)
    if (!caseId) {
      throw new Error("Failed to create or find case");
    }

    return { caseId, entities };
  },

  /**
   * Get case with entities and patient info
   */
  async getCaseWithEntities(
    supabase: SupabaseClientType,
    caseId: string,
  ): Promise<{
    case: CaseRow;
    entities: NormalizedEntities | undefined;
    patient: PatientRow | PatientRow[] | null;
    soapNotes: Database["public"]["Tables"]["soap_notes"]["Row"][] | null;
    dischargeSummaries:
      | Database["public"]["Tables"]["discharge_summaries"]["Row"][]
      | null;
    metadata: CaseMetadata;
  } | null> {
    const { data: caseData, error } = await supabase
      .from("cases")
      .select(
        `
                *,
                patient:patients(*),
                soap_notes(*),
                discharge_summaries(*)
            `,
      )
      .eq("id", caseId)
      .single();

    if (error || !caseData) {
      return null;
    }

    const metadata = (caseData.metadata as CaseMetadata | undefined) ?? {};
    const entities =
      (caseData.entity_extraction as NormalizedEntities | undefined) ??
      metadata.entities;

    const patient = Array.isArray(caseData.patient)
      ? (caseData.patient[0] ?? null)
      : (caseData.patient ?? null);

    const soapNotes = Array.isArray(caseData.soap_notes)
      ? caseData.soap_notes
      : caseData.soap_notes
        ? [caseData.soap_notes]
        : null;

    const dischargeSummaries = Array.isArray(caseData.discharge_summaries)
      ? caseData.discharge_summaries
      : caseData.discharge_summaries
        ? [caseData.discharge_summaries]
        : null;

    return {
      case: caseData,
      entities,
      patient,
      soapNotes,
      dischargeSummaries,
      metadata,
    };
  },

  /**
   * Auto-generate structured discharge summary for IDEXX Neo cases
   *
   * Called automatically when an IDEXX Neo case is imported.
   * Generates a SHORT, CONCISE, PET-OWNER FRIENDLY discharge summary.
   */
  async autoGenerateDischargeSummary(
    supabase: SupabaseClientType,
    userId: string,
    caseId: string,
    entities: NormalizedEntities,
  ): Promise<{ summaryId: string } | null> {
    try {
      // Check if discharge summary already exists for this case
      const { data: existingSummaries } = await supabase
        .from("discharge_summaries")
        .select("id")
        .eq("case_id", caseId)
        .limit(1);

      if (existingSummaries && existingSummaries.length > 0) {
        console.log(
          "[CasesService] Discharge summary already exists, skipping auto-generation",
          {
            caseId,
            existingSummaryId: existingSummaries[0]?.id,
          },
        );
        return null;
      }

      // Check if we have enough data to generate a summary
      const hasMinimumData =
        entities.patient.name &&
        (Boolean(entities.clinical.diagnoses?.length) ||
          Boolean(entities.clinical.chiefComplaint) ||
          Boolean(entities.clinical.visitReason));

      if (!hasMinimumData) {
        console.log("[CasesService] Insufficient data for auto-generation", {
          caseId,
          hasPatientName: !!entities.patient.name,
          hasDiagnoses: !!entities.clinical.diagnoses?.length,
          hasChiefComplaint: !!entities.clinical.chiefComplaint,
        });
        return null;
      }

      console.log(
        "[CasesService] Auto-generating discharge summary for IDEXX case",
        {
          caseId,
          patientName: entities.patient.name,
        },
      );

      // Generate structured discharge summary (dynamic import to avoid lazy-load constraint)
      const { generateStructuredDischargeSummaryWithRetry } =
        await import("@odis-ai/ai/generate-structured-discharge");
      const { structured, plainText } =
        await generateStructuredDischargeSummaryWithRetry({
          entityExtraction: entities,
          patientData: {
            name: entities.patient.name,
            species: entities.patient.species,
            breed: entities.patient.breed,
            owner_name: entities.patient.owner.name,
          },
        });

      // Save to database
      const { data: summary, error } = await supabase
        .from("discharge_summaries")
        .insert({
          case_id: caseId,
          user_id: userId,
          content: plainText,
          structured_content: structured as unknown as Json,
        })
        .select("id")
        .single();

      if (error) {
        console.error("[CasesService] Failed to save auto-generated summary", {
          caseId,
          error: error.message,
        });
        return null;
      }

      console.log(
        "[CasesService] Successfully auto-generated discharge summary",
        {
          caseId,
          summaryId: summary.id,
          patientName: structured.patientName,
        },
      );

      return { summaryId: summary.id };
    } catch (error) {
      // Don't throw - auto-generation is optional and shouldn't block case creation
      console.error("[CasesService] Auto-generation failed", {
        caseId,
        error: error instanceof Error ? error.message : String(error),
      });
      return null;
    }
  },

  /**
   * Extract entities from IDEXX consultation notes using AI
   *
   * Called during ingest for IDEXX cases to perform thorough entity extraction
   * from consultation notes (similar to what the orchestrator does).
   */
  async extractEntitiesFromIdexx(
    rawIdexxData: Record<string, unknown>,
  ): Promise<NormalizedEntities | null> {
    try {
      // 1. Get consultation_notes from IDEXX data
      const consultationNotes = rawIdexxData.consultation_notes as
        | string
        | undefined;

      if (!consultationNotes || consultationNotes.length < 50) {
        console.log(
          "[CasesService] Insufficient consultation notes for AI extraction",
          {
            hasNotes: !!consultationNotes,
            length: consultationNotes?.length ?? 0,
          },
        );
        return null; // Not enough text for AI extraction
      }

      // 2. Strip HTML tags (like orchestrator does)
      const cleanedText = consultationNotes
        .replace(/<[^>]*>/g, " ")
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&amp;/g, "&")
        .replace(/&nbsp;/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      if (cleanedText.length < 50) {
        console.log(
          "[CasesService] Cleaned consultation notes too short for AI extraction",
          {
            cleanedLength: cleanedText.length,
          },
        );
        return null;
      }

      // 3. Check for euthanasia (block these cases from discharge workflow)
      const isEuthanasia =
        cleanedText.toLowerCase().includes("euthanasia") ||
        cleanedText.toLowerCase().includes("euthanize") ||
        (rawIdexxData.appointment_type as string | undefined)
          ?.toLowerCase()
          .includes("euthanasia");

      if (isEuthanasia) {
        console.warn(
          "[CasesService] Euthanasia case detected at ingest - skipping AI extraction",
          {
            source: "idexx_consultation_notes",
          },
        );
        return null; // Don't extract entities for euthanasia cases
      }

      console.log(
        "[CasesService] Extracting entities from IDEXX consultation notes",
        {
          textLength: cleanedText.length,
        },
      );

      // 4. Run AI extraction (dynamic import to avoid lazy-load constraint)
      const { extractEntitiesWithRetry } =
        await import("@odis-ai/ai/normalize-scribe");
      const entities = await extractEntitiesWithRetry(
        cleanedText,
        "idexx_consultation_notes",
      );

      // 5. Enrich with IDEXX metadata (pet_name, owner info, billing)
      if (rawIdexxData.pet_name) {
        entities.patient.name = rawIdexxData.pet_name as string;
      }
      if (rawIdexxData.species) {
        const species = (rawIdexxData.species as string).toLowerCase();
        const validSpecies = [
          "dog",
          "cat",
          "bird",
          "rabbit",
          "other",
          "unknown",
        ] as const;
        type ValidSpecies = (typeof validSpecies)[number];
        entities.patient.species = validSpecies.includes(
          species as ValidSpecies,
        )
          ? (species as ValidSpecies)
          : "unknown";
      }
      if (rawIdexxData.breed) {
        entities.patient.breed = rawIdexxData.breed as string;
      }

      // Owner info from IDEXX metadata
      const clientFirstName = rawIdexxData.client_first_name as
        | string
        | undefined;
      const clientLastName = rawIdexxData.client_last_name as
        | string
        | undefined;
      const ownerName = rawIdexxData.owner_name as string | undefined;
      if (clientFirstName && clientLastName) {
        entities.patient.owner.name = `${clientFirstName} ${clientLastName}`;
      } else if (ownerName) {
        entities.patient.owner.name = ownerName;
      }

      const phone =
        (rawIdexxData.phone_number as string | undefined) ??
        (rawIdexxData.mobile_number as string | undefined);
      if (phone) {
        entities.patient.owner.phone = phone;
      }
      const email = rawIdexxData.email as string | undefined;
      if (email) {
        entities.patient.owner.email = email;
      }

      // Parse billing data for clinical context
      const acceptedItems = parseBillingString(
        rawIdexxData.products_services as string | undefined,
        false,
      );
      const declinedItems = parseBillingString(
        rawIdexxData.declined_products_services as string | undefined,
        true,
      );

      if (acceptedItems.length > 0) {
        entities.clinical.productsServicesProvided = acceptedItems.map(
          (item) =>
            item.quantity > 1
              ? `${item.productService} (Qty: ${item.quantity})`
              : item.productService,
        );
      }
      if (declinedItems.length > 0) {
        entities.clinical.productsServicesDeclined = declinedItems.map(
          (item) =>
            item.quantity > 1
              ? `${item.productService} (Qty: ${item.quantity})`
              : item.productService,
        );
      }

      console.log(
        "[CasesService] Successfully extracted entities from IDEXX consultation notes",
        {
          patientName: entities.patient.name,
          hasOwnerPhone: !!entities.patient.owner.phone,
          diagnosesCount: entities.clinical.diagnoses?.length ?? 0,
          medicationsCount: entities.clinical.medications?.length ?? 0,
          confidence: entities.confidence?.overall,
        },
      );

      return entities;
    } catch (error) {
      console.error(
        "[CasesService] Failed to extract entities from IDEXX notes",
        {
          error: error instanceof Error ? error.message : String(error),
        },
      );
      return null; // Non-blocking - fall back to basic mapping
    }
  },

  /**
   * Generate and store AI call intelligence at ingest-time
   *
   * Pre-generates assessment questions, warning signs, and other call
   * intelligence so that scheduling calls is instant (no AI wait time).
   */
  async generateAndStoreCallIntelligence(
    supabase: SupabaseClientType,
    caseId: string,
    entities: NormalizedEntities,
  ): Promise<AIGeneratedCallIntelligence | null> {
    try {
      // Check if we have enough data to generate useful call intelligence
      const hasMinimumData =
        entities.patient.name &&
        (Boolean(entities.clinical.diagnoses?.length) ||
          Boolean(entities.clinical.chiefComplaint) ||
          Boolean(entities.clinical.visitReason) ||
          Boolean(entities.clinical.medications?.length));

      if (!hasMinimumData) {
        console.log(
          "[CasesService] Insufficient data for call intelligence generation",
          {
            caseId,
            hasPatientName: !!entities.patient.name,
            hasDiagnoses: !!entities.clinical.diagnoses?.length,
            hasMedications: !!entities.clinical.medications?.length,
          },
        );
        return null;
      }

      console.log("[CasesService] Pre-generating call intelligence at ingest", {
        caseId,
        petName: entities.patient.name,
        diagnosis: entities.clinical.diagnoses?.[0],
      });

      // Dynamic import to avoid lazy-load constraint
      const { generateCallIntelligenceFromEntities } =
        await import("@odis-ai/ai/generate-assessment-questions");
      const intelligence = await generateCallIntelligenceFromEntities(entities);

      // Store in case metadata
      const { data: caseData } = await supabase
        .from("cases")
        .select("metadata")
        .eq("id", caseId)
        .single();

      const currentMetadata = (caseData?.metadata as CaseMetadata) ?? {};
      const updatedMetadata: CaseMetadata = {
        ...currentMetadata,
        callIntelligence: {
          ...intelligence,
          generatedAt: new Date().toISOString(),
        },
      };

      const { error: updateError } = await supabase
        .from("cases")
        .update({ metadata: updatedMetadata as Json })
        .eq("id", caseId);

      if (updateError) {
        console.error(
          "[CasesService] Failed to store call intelligence in metadata",
          {
            caseId,
            error: updateError.message,
          },
        );
        return null;
      }

      console.log("[CasesService] Successfully stored call intelligence", {
        caseId,
        questionCount: intelligence.assessmentQuestions?.length ?? 0,
        callApproach: intelligence.callApproach,
        shouldAskQuestions: intelligence.shouldAskClinicalQuestions,
        confidence: intelligence.confidence,
      });

      return intelligence;
    } catch (error) {
      // Non-blocking - call intelligence is optional
      console.error("[CasesService] Failed to generate call intelligence", {
        caseId,
        error: error instanceof Error ? error.message : String(error),
      });
      return null;
    }
  },

  /**
   * Schedule the discharge call linked to the case
   */
  async scheduleDischargeCall(
    supabase: SupabaseClientType,
    userId: string,
    caseId: string,
    options: CaseScheduleOptions,
    callExecutor?: ICallExecutor,
  ): Promise<ScheduledDischargeCall> {
    // 1. Fetch Case Data to build variables
    let caseInfo = await this.getCaseWithEntities(supabase, caseId);
    if (!caseInfo) throw new Error("Case not found");

    let entities = caseInfo.entities;

    // 1a. Enrich entities with database values (database takes priority)
    this.enrichEntitiesWithPatient(entities, caseInfo.patient);

    // 1b. Enrich with client instructions from SOAP notes or discharge summaries
    if (entities) {
      let clientInstructions: string | null = null;

      // Priority 1: SOAP notes client_instructions
      if (caseInfo.soapNotes && caseInfo.soapNotes.length > 0) {
        const latestSoapNote = caseInfo.soapNotes[0];
        if (latestSoapNote?.client_instructions) {
          clientInstructions = latestSoapNote.client_instructions;
          console.log(
            "[CasesService] Using client instructions from SOAP notes",
            {
              caseId,
              source: "soap_notes.client_instructions",
              preview: clientInstructions?.substring(0, 100) ?? "",
            },
          );
        } else if (latestSoapNote?.plan) {
          // Priority 2: SOAP notes plan
          clientInstructions = latestSoapNote.plan;
          console.log("[CasesService] Using plan from SOAP notes", {
            caseId,
            source: "soap_notes.plan",
            preview: clientInstructions?.substring(0, 100) ?? "",
          });
        }
      }

      // Priority 3: Discharge summaries content
      if (
        !clientInstructions &&
        caseInfo.dischargeSummaries &&
        caseInfo.dischargeSummaries.length > 0
      ) {
        const latestDischargeSummary = caseInfo.dischargeSummaries[0];
        if (latestDischargeSummary?.content) {
          clientInstructions = latestDischargeSummary.content;
          console.log("[CasesService] Using discharge summary content", {
            caseId,
            source: "discharge_summaries.content",
            preview: clientInstructions?.substring(0, 100) ?? "",
          });
        }
      }

      // Add to entities if found
      if (clientInstructions) {
        entities.clinical.followUpInstructions = clientInstructions;
        console.log(
          "[CasesService] Enriched entities with client instructions",
          {
            caseId,
            instructionsLength: clientInstructions.length,
          },
        );
      }
    }

    // 2. Fallback: If entities are missing or incomplete, try extracting from transcription
    if (!entities || this.isEntitiesIncomplete(entities)) {
      console.log(
        "[CasesService] Entities missing or incomplete, attempting extraction from transcription",
        {
          caseId,
          hasEntities: !!entities,
          missingFields: entities
            ? this.getMissingEntityFields(entities)
            : ["all"],
        },
      );

      // Fetch transcription text
      const { data: transcriptionData } = await supabase
        .from("transcriptions")
        .select("transcript")
        .eq("case_id", caseId)
        .order("created_at", { ascending: false })
        .limit(1)
        .maybeSingle();

      if (transcriptionData?.transcript) {
        try {
          // Extract entities from transcription (dynamic import to avoid lazy-load constraint)
          const { extractEntitiesWithRetry } =
            await import("@odis-ai/ai/normalize-scribe");
          const extractedEntities = await extractEntitiesWithRetry(
            transcriptionData.transcript,
            "transcript",
          );

          // Merge with existing entities (if any), with extracted taking precedence
          entities = entities
            ? this.mergeEntitiesForExtraction(entities, extractedEntities)
            : extractedEntities;

          // Update case metadata with enriched entities
          const updatedMetadata: CaseMetadata = {
            ...caseInfo.metadata,
            entities,
          };

          await supabase
            .from("cases")
            .update({ metadata: updatedMetadata as Json })
            .eq("id", caseId);

          console.log(
            "[CasesService] Successfully extracted and merged entities from transcription",
            {
              caseId,
              extractedFields: this.getExtractedFields(extractedEntities),
            },
          );

          // Refresh case info with updated entities
          caseInfo = await this.getCaseWithEntities(supabase, caseId);
          if (!caseInfo) throw new Error("Case not found after update");
          entities = caseInfo.entities;

          // Re-apply database enrichment after re-fetch
          // This ensures database values take priority even after transcription extraction
          this.enrichEntitiesWithPatient(entities, caseInfo.patient);
        } catch (extractionError) {
          console.error(
            "[CasesService] Failed to extract entities from transcription",
            {
              caseId,
              error: extractionError,
            },
          );
          // Continue with existing entities (or throw if none)
          if (!entities) {
            throw new Error(
              "Case has no entities and extraction from transcription failed",
            );
          }
        }
      } else {
        // No transcription available
        if (!entities) {
          throw new Error(
            "Case has no entities and no transcription available for extraction",
          );
        }
        console.warn(
          "[CasesService] Entities incomplete but no transcription found",
          {
            caseId,
            missingFields: this.getMissingEntityFields(entities),
          },
        );
      }
    }

    if (!entities) throw new Error("Case has no entities");

    // 2. Extract AI-extracted variables (species, breed, age, diagnoses, etc.)
    // Dynamic import to avoid lazy-load constraint
    const { extractVapiVariablesFromEntities } =
      await import("@odis-ai/vapi/extract-variables");
    const extractedVars = extractVapiVariablesFromEntities(entities);

    // 2a. Check for pre-generated AI call intelligence (generated at ingest-time)
    // This eliminates AI wait time when scheduling calls for IDEXX cases
    let aiIntelligence: AIGeneratedCallIntelligence | null = null;
    // Safely access callIntelligence from metadata
    const caseMeta = caseInfo?.metadata as CaseMetadata | null;
    const preGeneratedIntelligence = caseMeta?.callIntelligence;

    if (preGeneratedIntelligence) {
      // Use pre-generated intelligence from ingest-time (instant!)
      console.log(
        "[CasesService] Using pre-generated call intelligence from ingest",
        {
          caseId,
          generatedAt: preGeneratedIntelligence.generatedAt,
          questionCount:
            preGeneratedIntelligence.assessmentQuestions?.length ?? 0,
          callApproach: preGeneratedIntelligence.callApproach,
          confidence: preGeneratedIntelligence.confidence,
        },
      );

      aiIntelligence = {
        caseContextSummary: preGeneratedIntelligence.caseContextSummary,
        assessmentQuestions: preGeneratedIntelligence.assessmentQuestions,
        warningSignsToMonitor: preGeneratedIntelligence.warningSignsToMonitor,
        normalExpectations: preGeneratedIntelligence.normalExpectations,
        emergencyCriteria: preGeneratedIntelligence.emergencyCriteria,
        shouldAskClinicalQuestions:
          preGeneratedIntelligence.shouldAskClinicalQuestions,
        callApproach: preGeneratedIntelligence.callApproach,
        confidence: preGeneratedIntelligence.confidence,
      };
    } else {
      // Generate AI call intelligence at schedule-time (for non-IDEXX cases or legacy data)
      console.log(
        "[CasesService] Generating AI call intelligence at schedule-time",
        {
          caseId,
          petName: entities.patient.name,
          diagnosis: entities.clinical.diagnoses?.[0],
        },
      );

      // Dynamic import to avoid lazy-load constraint
      const { generateCallIntelligenceFromEntities } =
        await import("@odis-ai/ai/generate-assessment-questions");
      const intelligence = await generateCallIntelligenceFromEntities(entities);
      aiIntelligence = {
        caseContextSummary: intelligence.caseContextSummary,
        assessmentQuestions: intelligence.assessmentQuestions,
        warningSignsToMonitor: intelligence.warningSignsToMonitor,
        normalExpectations: intelligence.normalExpectations,
        emergencyCriteria: intelligence.emergencyCriteria,
        shouldAskClinicalQuestions: intelligence.shouldAskClinicalQuestions,
        callApproach: intelligence.callApproach,
        confidence: intelligence.confidence,
      };

      console.log("[CasesService] AI call intelligence generated", {
        caseId,
        questionCount: intelligence.assessmentQuestions?.length ?? 0,
        callApproach: intelligence.callApproach,
        shouldAskQuestions: intelligence.shouldAskClinicalQuestions,
        confidence: intelligence.confidence,
      });
    }

    // 3. Build Dynamic Variables with knowledge base integration
    // Use extractFirstName to get only the first word of the pet name
    // (many vet systems store "FirstName LastName" but we only want first name for calls)
    // Dynamic imports to avoid lazy-load constraint
    const { buildDynamicVariables } =
      await import("@odis-ai/vapi/knowledge-base");
    const { extractFirstName, normalizeVariablesToSnakeCase } =
      await import("@odis-ai/vapi/utils");
    const variablesResult = buildDynamicVariables({
      baseVariables: {
        clinicName: options.clinicName ?? "Your Clinic",
        agentName: "Sarah",
        petName: extractFirstName(entities.patient.name),
        ownerName: entities.patient.owner.name,
        // Keep date phrasing generic to avoid incorrect relative day mentions
        appointmentDate: "recent visit",
        callType: "discharge",
        clinicPhone: options.clinicPhone ?? "",
        emergencyPhone: options.emergencyPhone ?? options.clinicPhone ?? "",
        dischargeSummary:
          options.summaryContent ?? generateSummaryFromEntities(entities),

        medications: entities.clinical.medications
          ?.map((m) => `${m.name} ${m.dosage ?? ""} ${m.frequency ?? ""}`)
          .join(", "),
        vaccinations: entities.clinical.vaccinations
          ?.map((v) => v.name)
          .join(", "),
        nextSteps: entities.clinical.followUpInstructions,

        // Include species/breed/age if available from entities
        // Note: petSpecies is limited to "dog" | "cat" | "other" for buildDynamicVariables
        // but extractedVars will include full patient_species (dog, cat, bird, rabbit, etc.)
        petSpecies:
          entities.patient.species === "dog" ||
          entities.patient.species === "cat"
            ? entities.patient.species
            : entities.patient.species
              ? "other"
              : undefined,
        petAge: entities.patient.age
          ? (() => {
              const num = parseFloat(
                entities.patient.age.replace(/[^0-9.]/g, ""),
              );
              return isNaN(num) ? undefined : num;
            })()
          : undefined,
        petWeight: entities.patient.weight
          ? (() => {
              const num = parseFloat(
                entities.patient.weight.replace(/[^0-9.]/g, ""),
              );
              return isNaN(num) ? undefined : num;
            })()
          : undefined,
      },
      strict: false,
      // useDefaults is deprecated (static KB removed)
      useDefaults: false,
      // Pass AI-generated intelligence
      aiGeneratedIntelligence: aiIntelligence ?? undefined,
    });

    // 4. Merge extracted variables with buildDynamicVariables result
    // Extracted vars (snake_case) are merged first, then buildDynamicVariables vars (camelCase)
    // are normalized and merged, with manual vars taking precedence
    const mergedVariables = {
      ...extractedVars, // Already snake_case (patient_species, patient_breed, etc.)
      ...normalizeVariablesToSnakeCase(
        variablesResult.variables as unknown as Record<string, unknown>,
      ), // Convert camelCase to snake_case
    };

    // 3. Insert Scheduled Call
    // Get clinic-specific VAPI configuration (falls back to env vars if not configured)
    const clinicVapiConfig = await getClinicVapiConfigByUserId(
      userId,
      supabase,
    );
    const assistantId =
      options.assistantId ?? clinicVapiConfig.outboundAssistantId;
    const phoneNumberId =
      options.phoneNumberId ?? clinicVapiConfig.phoneNumberId;

    console.log("[CasesService] Using VAPI config", {
      source: clinicVapiConfig.source,
      clinicName: clinicVapiConfig.clinicName,
      hasAssistantId: !!assistantId,
      hasPhoneNumberId: !!phoneNumberId,
    });

    // Get customer phone (with test mode support)
    let customerPhone = entities.patient.owner.phone ?? "";

    // Check if test mode is enabled and get schedule override
    const { data: userSettings } = await supabase
      .from("users")
      .select(
        "test_mode_enabled, test_contact_phone, test_contact_name, default_schedule_delay_minutes",
      )
      .eq("id", userId)
      .single();

    const testModeEnabled = userSettings?.test_mode_enabled ?? false;
    const defaultScheduleDelayMinutes =
      userSettings?.default_schedule_delay_minutes;

    if (testModeEnabled) {
      if (!userSettings?.test_contact_phone) {
        throw new Error(
          "Test mode is enabled but test contact phone is not configured",
        );
      }

      console.log(
        "[CasesService] Test mode enabled - redirecting call to test contact",
        {
          originalPhone: customerPhone,
          testPhone: userSettings.test_contact_phone,
          testContactName: userSettings.test_contact_name,
        },
      );

      customerPhone = userSettings.test_contact_phone;
    } else if (!customerPhone) {
      throw new Error("Patient phone number is required to schedule call");
    }

    // Normalize phone number to E.164 format (+1XXXXXXXXXX for US numbers)
    const normalizedPhone = normalizeToE164(customerPhone);
    if (!normalizedPhone) {
      throw new Error(`Invalid phone number format: ${customerPhone}`);
    }
    customerPhone = normalizedPhone;

    // Determine scheduled time using server time
    // Always use server time to avoid timezone and clock drift issues
    const serverNow = new Date();
    let scheduledAt: Date;

    if (options.scheduledAt) {
      // Validate that provided scheduled time is in the future
      if (options.scheduledAt <= serverNow) {
        throw new Error(
          `Scheduled time must be in the future. Provided: ${options.scheduledAt.toISOString()}, Server now: ${serverNow.toISOString()}`,
        );
      }
      scheduledAt = options.scheduledAt;
    } else {
      // Use user's default schedule delay override if set, otherwise use system defaults
      let delayMinutes: number;
      if (
        defaultScheduleDelayMinutes !== null &&
        defaultScheduleDelayMinutes !== undefined
      ) {
        delayMinutes = defaultScheduleDelayMinutes;
        console.log("[CasesService] Using user override for schedule delay", {
          delayMinutes,
          serverNow: serverNow.toISOString(),
        });
      } else if (testModeEnabled) {
        // Test mode: schedule for 1 minute from server time
        delayMinutes = 1;
      } else {
        // Normal mode: schedule for 2 minutes from server time
        delayMinutes = 2;
      }

      scheduledAt = new Date(serverNow.getTime() + delayMinutes * 60 * 1000);
      console.log("[CasesService] Scheduling call", {
        delayMinutes,
        testModeEnabled,
        serverNow: serverNow.toISOString(),
        scheduledAt: scheduledAt.toISOString(),
      });
    }

    // Auto-stagger calls to prevent VAPI concurrency limit (10 calls max)
    // Query existing queued calls in the same 5-minute window for this user
    const STAGGER_MINUTES = 2; // Match batch processor stagger interval
    const windowStart = new Date(scheduledAt.getTime() - 2.5 * 60 * 1000);
    const windowEnd = new Date(scheduledAt.getTime() + 2.5 * 60 * 1000);

    const { count: existingCallsInWindow } = await supabase
      .from("scheduled_discharge_calls")
      .select("id", { count: "exact", head: true })
      .eq("user_id", userId)
      .eq("status", "queued")
      .neq("case_id", caseId) // Exclude current case if being updated
      .gte("scheduled_for", windowStart.toISOString())
      .lte("scheduled_for", windowEnd.toISOString());

    if (existingCallsInWindow && existingCallsInWindow > 0) {
      const staggerOffset = existingCallsInWindow * STAGGER_MINUTES * 60 * 1000;
      const originalScheduledAt = scheduledAt;
      scheduledAt = new Date(scheduledAt.getTime() + staggerOffset);

      console.log(
        "[CasesService] Auto-staggering call to prevent concurrency limit",
        {
          caseId,
          existingCallsInWindow,
          staggerMinutes: existingCallsInWindow * STAGGER_MINUTES,
          originalScheduledAt: originalScheduledAt.toISOString(),
          staggeredScheduledAt: scheduledAt.toISOString(),
        },
      );
    }

    // Check if a call already exists for this case
    // If it exists, update it instead of creating a new one to persist status
    const { data: existingCall } = await supabase
      .from("scheduled_discharge_calls")
      .select("id, status, vapi_call_id, scheduled_for")
      .eq("case_id", caseId)
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    let scheduledCall: ScheduledDischargeCall;

    if (existingCall) {
      // Update existing call - preserve status if call is already in progress/completed
      // Only update to "queued" if status is null or if explicitly resetting
      const currentStatus = existingCall.status;
      const shouldPreserveStatus =
        currentStatus &&
        (currentStatus === "in_progress" ||
          currentStatus === "ringing" ||
          currentStatus === "completed");

      const updateData: Partial<ScheduledCallRow> = {
        assistant_id: assistantId ?? "",
        phone_number_id: phoneNumberId ?? "",
        customer_phone: customerPhone,
        user_id: userId,
        scheduled_for: scheduledAt.toISOString(),
        status: shouldPreserveStatus
          ? (currentStatus as
              | "queued"
              | "in_progress"
              | "ringing"
              | "completed"
              | "failed"
              | "canceled")
          : ("queued" as const),
        dynamic_variables: mergedVariables as Json,
        metadata: {
          notes: options.notes,
          retry_count: 0,
          max_retries: 3,
        } as Json,
      };

      const { data: updatedCall, error: updateError } = await supabase
        .from("scheduled_discharge_calls")
        .update(updateData)
        .eq("id", existingCall.id)
        .select()
        .single();

      if (updateError || !updatedCall) {
        throw new Error(
          `Failed to update existing call: ${
            updateError?.message ?? "Unknown error"
          }`,
        );
      }

      scheduledCall = updatedCall as ScheduledDischargeCall;

      console.log("[CasesService] Updated existing call for case", {
        caseId,
        callId: scheduledCall.id,
        preservedStatus: shouldPreserveStatus,
        status: scheduledCall.status,
      });

      // If updating an existing call, only reschedule QStash if the scheduled time changed
      // or if there's no existing QStash message ID
      const existingMetadata = scheduledCall.metadata;
      const hasExistingQStashId = !!existingMetadata?.qstash_message_id;
      const scheduledTimeChanged =
        existingCall.scheduled_for !== scheduledAt.toISOString();

      if (!hasExistingQStashId || scheduledTimeChanged) {
        if (testModeEnabled) {
          // Test mode: execute call immediately without QStash delay
          console.log(
            "[CasesService] Test mode enabled - executing call immediately",
            {
              callId: scheduledCall.id,
              testPhone: customerPhone,
            },
          );

          // Use injected executor if provided, otherwise dynamic import
          let result;
          if (callExecutor) {
            result = await callExecutor.executeScheduledCall(
              scheduledCall.id,
              supabase,
            );
          } else {
            // Dynamic import to avoid circular dependencies
            const { executeScheduledCall } =
              // eslint-disable-next-line @nx/enforce-module-boundaries
              await import("@odis-ai/services-discharge/call-executor");
            result = await executeScheduledCall(scheduledCall.id, supabase);
          }

          if (!result.success) {
            console.error(
              "[CasesService] Immediate call execution failed - call may not execute",
              {
                callId: scheduledCall.id,
                error: result.error,
              },
            );
            // Don't throw - call record was created successfully
          }
        } else {
          // Normal mode: reschedule QStash for the updated time
          const qstashMessageId = await scheduleCallExecution(
            scheduledCall.id,
            scheduledAt,
          );

          const updatedMetadata: ScheduledCallMetadata = {
            ...existingMetadata,
            qstash_message_id: qstashMessageId,
          };

          const { error: updateError } = await supabase
            .from("scheduled_discharge_calls")
            .update({
              metadata: updatedMetadata as Json,
            })
            .eq("id", scheduledCall.id);

          if (updateError) {
            console.error(
              "[CasesService] Error updating QStash message ID:",
              updateError,
            );
            // Don't throw - call was updated successfully
          }
        }
      }
    } else {
      // Create new call
      const scheduledCallInsert: ScheduledCallInsert = {
        user_id: userId,
        case_id: caseId,
        assistant_id: assistantId ?? "",
        phone_number_id: phoneNumberId ?? "",
        customer_phone: customerPhone,
        scheduled_for: scheduledAt.toISOString(),
        status: "queued" as const,
        dynamic_variables: mergedVariables as Json, // Use merged variables with AI-extracted data
        metadata: {
          notes: options.notes,
          retry_count: 0,
          max_retries: 3,
        } as Json,
      };

      const { data: newCall, error } = await supabase
        .from("scheduled_discharge_calls")
        .insert(scheduledCallInsert)
        .select()
        .single();

      if (error || !newCall) {
        throw new Error(
          `Failed to schedule call: ${error?.message ?? "Unknown error"}`,
        );
      }

      scheduledCall = newCall as ScheduledDischargeCall;

      // 4. Execute immediately in test mode, otherwise trigger QStash for new call
      if (testModeEnabled) {
        // Test mode: execute call immediately without QStash delay
        console.log(
          "[CasesService] Test mode enabled - executing call immediately",
          {
            callId: scheduledCall.id,
            testPhone: customerPhone,
          },
        );

        // Use injected executor if provided, otherwise dynamic import
        let result;
        if (callExecutor) {
          result = await callExecutor.executeScheduledCall(
            scheduledCall.id,
            supabase,
          );
        } else {
          // Dynamic import to avoid circular dependencies
          const { executeScheduledCall } =
            // eslint-disable-next-line @nx/enforce-module-boundaries
            await import("@odis-ai/services-discharge/call-executor");
          result = await executeScheduledCall(scheduledCall.id, supabase);
        }

        if (!result.success) {
          console.error(
            "[CasesService] Immediate call execution failed - call may not execute",
            {
              callId: scheduledCall.id,
              error: result.error,
            },
          );
          // Don't throw - call record was created successfully
        }
      } else {
        // Normal mode: trigger QStash
        const qstashMessageId = await scheduleCallExecution(
          scheduledCall.id,
          scheduledAt,
        );

        // Update with QStash ID
        const updatedMetadata: ScheduledCallMetadata = {
          ...(scheduledCall.metadata ?? {}),
          qstash_message_id: qstashMessageId,
        };

        const { error: updateError } = await supabase
          .from("scheduled_discharge_calls")
          .update({
            metadata: updatedMetadata as Json,
          })
          .eq("id", scheduledCall.id);

        if (updateError) {
          console.error(
            "[CasesService] Error updating QStash message ID:",
            updateError,
          );
          // Don't throw - call was scheduled successfully
        }
      }
    }

    return scheduledCall;
  },

  /**
   * Check if entities are incomplete (missing critical fields like species, breed, age)
   */
  isEntitiesIncomplete(entities: NormalizedEntities): boolean {
    const missingFields = this.getMissingEntityFields(entities);
    // Consider incomplete if missing species, breed, age, or weight
    return (
      missingFields.includes("species") ||
      missingFields.includes("breed") ||
      missingFields.includes("age") ||
      missingFields.includes("weight")
    );
  },

  /**
   * Get list of missing entity fields
   */
  getMissingEntityFields(entities: NormalizedEntities): string[] {
    const missing: string[] = [];
    if (!entities.patient.species || entities.patient.species === "unknown") {
      missing.push("species");
    }
    if (!entities.patient.breed) {
      missing.push("breed");
    }
    if (!entities.patient.age) {
      missing.push("age");
    }
    if (!entities.patient.weight) {
      missing.push("weight");
    }
    return missing;
  },

  /**
   * Enrich entities with database patient values
   *
   * Database values take priority over AI-extracted metadata values.
   * This ensures accurate patient information even when AI extraction fails.
   *
   * @param entities - The entities object to enrich (modified in place)
   * @param patient - Patient record from database (single or array)
   */
  enrichEntitiesWithPatient(
    entities: NormalizedEntities | undefined,
    patient: PatientRow | PatientRow[] | null,
  ): void {
    if (!entities || !patient) {
      return;
    }

    // Handle both single patient and array of patients
    const patientData = Array.isArray(patient) ? patient[0] : patient;

    if (!patientData) {
      return;
    }

    // Enrich patient name from database (database takes priority)
    if (patientData.name && patientData.name.trim() !== "") {
      entities.patient.name = patientData.name;
    }

    // Enrich patient demographics from database
    if (patientData.species) {
      entities.patient.species =
        patientData.species as NormalizedEntities["patient"]["species"];
    }
    if (patientData.breed) {
      entities.patient.breed = patientData.breed;
    }
    if (patientData.sex) {
      entities.patient.sex =
        patientData.sex as NormalizedEntities["patient"]["sex"];
    }
    if (patientData.weight_kg) {
      entities.patient.weight = `${patientData.weight_kg} kg`;
    }

    // Enrich owner information from database
    if (patientData.owner_name) {
      entities.patient.owner.name = patientData.owner_name;
    }
    if (patientData.owner_phone) {
      entities.patient.owner.phone = patientData.owner_phone;
    }
    if (patientData.owner_email) {
      entities.patient.owner.email = patientData.owner_email;
    }

    console.log(
      "[CasesService] Enriched entities with patient database values",
      {
        enrichedFields: {
          name: patientData.name,
          species: patientData.species,
          breed: patientData.breed,
          sex: patientData.sex,
          weight: patientData.weight_kg,
          ownerName: patientData.owner_name,
          ownerPhone: patientData.owner_phone,
        },
      },
    );
  },

  /**
   * Get list of successfully extracted fields (for logging)
   */
  getExtractedFields(entities: NormalizedEntities): string[] {
    const extracted: string[] = [];
    if (entities.patient.species && entities.patient.species !== "unknown") {
      extracted.push("species");
    }
    if (entities.patient.breed) {
      extracted.push("breed");
    }
    if (entities.patient.age) {
      extracted.push("age");
    }
    if (entities.patient.weight) {
      extracted.push("weight");
    }
    return extracted;
  },

  /**
   * Merge two entity sets, with extractedEntities taking precedence for missing fields
   * Used when re-extracting from transcription to fill in missing data
   */
  mergeEntitiesForExtraction(
    existing: NormalizedEntities,
    extracted: NormalizedEntities,
  ): NormalizedEntities {
    return {
      ...existing,
      patient: {
        ...existing.patient,
        // Use extracted values if existing is missing/unknown
        species:
          existing.patient.species && existing.patient.species !== "unknown"
            ? existing.patient.species
            : (extracted.patient.species ?? existing.patient.species),
        breed: existing.patient.breed ?? extracted.patient.breed,
        age: existing.patient.age ?? extracted.patient.age,
        sex:
          existing.patient.sex && existing.patient.sex !== "unknown"
            ? existing.patient.sex
            : (extracted.patient.sex ?? existing.patient.sex),
        weight: existing.patient.weight ?? extracted.patient.weight,
        owner: {
          ...existing.patient.owner,
          name: existing.patient.owner.name ?? extracted.patient.owner.name,
          phone: existing.patient.owner.phone ?? extracted.patient.owner.phone,
          email: existing.patient.owner.email ?? extracted.patient.owner.email,
        },
      },
      clinical: {
        ...existing.clinical,
        // Merge clinical data, preferring extracted for missing fields
        chiefComplaint:
          existing.clinical.chiefComplaint ?? extracted.clinical.chiefComplaint,
        visitReason:
          existing.clinical.visitReason ?? extracted.clinical.visitReason,
        presentingSymptoms:
          (existing.clinical.presentingSymptoms?.length ?? 0 > 0)
            ? existing.clinical.presentingSymptoms
            : extracted.clinical.presentingSymptoms,
        diagnoses:
          (existing.clinical.diagnoses?.length ?? 0 > 0)
            ? existing.clinical.diagnoses
            : extracted.clinical.diagnoses,
        medications:
          (existing.clinical.medications?.length ?? 0 > 0)
            ? existing.clinical.medications
            : extracted.clinical.medications,
        followUpInstructions:
          existing.clinical.followUpInstructions ??
          extracted.clinical.followUpInstructions,
        recheckRequired:
          existing.clinical.recheckRequired ??
          extracted.clinical.recheckRequired,
      },
      // Keep existing caseType and confidence, but update extractedAt
      caseType: existing.caseType ?? extracted.caseType,
      confidence: existing.confidence,
      extractedAt: extracted.extractedAt ?? existing.extractedAt,
      warnings: [
        ...(existing.warnings ?? []),
        ...(extracted.warnings ?? []),
      ].filter((w, i, arr) => arr.indexOf(w) === i), // Remove duplicates
    };
  },

  /**
   * Merge logic for entities (used during case creation/update)
   */
  mergeEntities(
    current: NormalizedEntities | undefined,
    incoming: NormalizedEntities,
  ): NormalizedEntities {
    if (!current) return incoming;
    return incoming;
  },

  /**
   * Delete a case by IDEXX appointment ID (for no-show handling)
   *
   * Used when an appointment becomes a no-show and should be removed from the cases table.
   * Only deletes cases with matching external_id pattern "idexx-appt-{appointmentId}".
   *
   * @param supabase - Supabase client
   * @param userId - User ID to scope the deletion
   * @param appointmentId - IDEXX appointment ID
   * @returns true if a case was deleted, false if no matching case found
   */
  async deleteNoShowCase(
    supabase: SupabaseClientType,
    userId: string,
    appointmentId: string,
  ): Promise<boolean> {
    const externalId = `idexx-appt-${appointmentId}`;

    // First check if the case exists
    const { data: existingCase } = await supabase
      .from("cases")
      .select("id")
      .eq("user_id", userId)
      .eq("external_id", externalId)
      .maybeSingle();

    if (!existingCase) {
      console.log("[CasesService] No case found to delete for no-show", {
        userId,
        appointmentId,
        externalId,
      });
      return false;
    }

    // Delete the case (cascades to related records via FK constraints)
    const { error } = await supabase
      .from("cases")
      .delete()
      .eq("user_id", userId)
      .eq("external_id", externalId);

    if (error) {
      console.error("[CasesService] Failed to delete no-show case", {
        userId,
        appointmentId,
        externalId,
        error: error.message,
      });
      return false;
    }

    console.log("[CasesService] Deleted no-show case", {
      userId,
      appointmentId,
      externalId,
      caseId: existingCase.id,
    });

    return true;
  },
};

// --- Helpers ---

function mapCaseTypeToDb(
  type: string,
): Database["public"]["Enums"]["CaseType"] {
  // DB: "checkup" | "emergency" | "surgery" | "follow_up"
  // Note: euthanasia maps to follow_up for DB, but discharge blocking happens at entity level
  const map: Record<string, Database["public"]["Enums"]["CaseType"]> = {
    checkup: "checkup",
    vaccination: "checkup",
    consultation: "checkup",
    exam: "checkup",
    emergency: "emergency",
    surgery: "surgery",
    dental: "surgery",
    follow_up: "follow_up",
    diagnostic: "follow_up",
    euthanasia: "follow_up", // DB doesn't have euthanasia type, but we check entities.caseType for discharge blocking
    other: "follow_up",
    unknown: "checkup",
  };
  return map[type] ?? "checkup";
}

function mapIdexxToEntities(data: Record<string, unknown>): NormalizedEntities {
  const petName = typeof data.pet_name === "string" ? data.pet_name : "Unknown";

  // Map to valid species enum values
  const validSpecies = [
    "dog",
    "cat",
    "bird",
    "rabbit",
    "other",
    "unknown",
  ] as const;
  type ValidSpecies = (typeof validSpecies)[number];
  const rawSpecies =
    typeof data.species === "string" ? data.species.toLowerCase() : "unknown";
  const species: ValidSpecies = validSpecies.includes(
    rawSpecies as ValidSpecies,
  )
    ? (rawSpecies as ValidSpecies)
    : "unknown";

  const clientFirstName =
    typeof data.client_first_name === "string" ? data.client_first_name : "";
  const clientLastName =
    typeof data.client_last_name === "string" ? data.client_last_name : "";
  const ownerName =
    typeof data.owner_name === "string" ? data.owner_name : "Unknown";
  const phone =
    typeof data.phone_number === "string"
      ? data.phone_number
      : typeof data.mobile_number === "string"
        ? data.mobile_number
        : undefined;
  const email = typeof data.email === "string" ? data.email : undefined;

  // Parse billing data for AI context
  const acceptedItems = parseBillingString(
    data.products_services as string | undefined,
    false,
  );
  const declinedItems = parseBillingString(
    data.declined_products_services as string | undefined,
    true,
  );

  // Extract product names for clinical entities
  const productsServicesProvided =
    acceptedItems.length > 0
      ? acceptedItems.map((item) =>
          item.quantity > 1
            ? `${item.productService} (Qty: ${item.quantity})`
            : item.productService,
        )
      : undefined;

  const productsServicesDeclined =
    declinedItems.length > 0
      ? declinedItems.map((item) =>
          item.quantity > 1
            ? `${item.productService} (Qty: ${item.quantity})`
            : item.productService,
        )
      : undefined;

  return {
    patient: {
      name: petName,
      species: species,
      owner: {
        name:
          clientFirstName && clientLastName
            ? `${clientFirstName} ${clientLastName}`
            : ownerName,
        phone: phone,
        email: email,
      },
    },
    clinical: {
      medications: [],
      diagnoses: [],
      // Include billing data for AI context (discharge summaries, calls)
      productsServicesProvided,
      productsServicesDeclined,
    },
    caseType: "checkup",
    confidence: { overall: 0.5, patient: 0.5, clinical: 0.5 },
    extractedAt: new Date().toISOString(),
  };
}

function parseWeight(weightStr?: string): number | null {
  if (!weightStr) return null;
  const num = parseFloat(weightStr);
  return isNaN(num) ? null : num;
}

/**
 * Parse IDEXX appointment date/time into ISO timestamp
 * Handles formats like "2024-01-15" and "14:30"
 */
function parseScheduledAt(
  rawData?: Record<string, unknown> | null,
): string | null {
  if (!rawData) return null;

  const appointmentDate = rawData.appointment_date as string | undefined;
  const appointmentTime = rawData.appointment_time as string | undefined;

  if (!appointmentDate) return null;

  try {
    if (appointmentTime) {
      // Combine date and time: "2024-01-15" + "14:30" -> "2024-01-15T14:30:00"
      const dateTime = new Date(`${appointmentDate}T${appointmentTime}:00`);
      if (!isNaN(dateTime.getTime())) {
        return dateTime.toISOString();
      }
    }
    // Date only fallback
    const dateOnly = new Date(appointmentDate);
    if (!isNaN(dateOnly.getTime())) {
      return dateOnly.toISOString();
    }
  } catch {
    // Invalid date format
  }

  return null;
}

function generateSummaryFromEntities(entities: NormalizedEntities): string {
  const parts = [];
  if (entities.clinical.diagnoses?.length) {
    parts.push(`Diagnoses: ${entities.clinical.diagnoses.join(", ")}.`);
  }
  if (entities.clinical.medications?.length) {
    const medList = entities.clinical.medications
      .map((m) => `${m.name} (${m.dosage ?? ""}, ${m.frequency ?? ""})`)
      .join("; ");
    parts.push(`Medications: ${medList}.`);
  }
  if (entities.clinical.followUpInstructions) {
    parts.push(`Instructions: ${entities.clinical.followUpInstructions}`);
  }
  return parts.join(" ");
}
