import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { verifySignatureAppRouter } from "@upstash/qstash/dist/nextjs";
import { createServiceClient } from "~/lib/supabase/server";
import { createPhoneCall } from "~/lib/vapi/client";
import { mapVapiStatus } from "~/lib/vapi/client";
import { CasesService } from "~/lib/services/cases-service";
import { buildDynamicVariables } from "~/lib/vapi/knowledge-base";

/**
 * Execute Call Webhook
 *
 * POST /api/webhooks/execute-call
 *
 * This webhook is triggered by QStash at the scheduled time.
 * It executes the scheduled call via VAPI.
 *
 * Security: QStash signature verification is critical
 */

interface ExecuteCallPayload {
  callId: string;
}

/**
 * Handle execution of scheduled call
 */
async function handler(req: NextRequest) {
  try {
    console.log("[EXECUTE_CALL] Webhook triggered");

    // Parse request body
    const payload = (await req.json()) as ExecuteCallPayload;
    const { callId } = payload;

    if (!callId) {
      console.error("[EXECUTE_CALL] Missing callId in payload");
      return NextResponse.json(
        { error: "Missing callId in payload" },
        { status: 400 },
      );
    }

    console.log("[EXECUTE_CALL] Processing call", { callId });

    // Get Supabase service client (bypass RLS)
    const supabase = await createServiceClient();

    // Fetch scheduled call from database
    const { data: call, error } = await supabase
      .from("scheduled_discharge_calls")
      .select("*")
      .eq("id", callId)
      .single();

    if (error || !call) {
      console.error("[EXECUTE_CALL] Call not found", {
        callId,
        error,
      });
      return NextResponse.json(
        { error: "Scheduled call not found" },
        { status: 404 },
      );
    }

    // Check if call is still in queued status (prevent double execution)
    if (call.status !== "queued") {
      console.warn("[EXECUTE_CALL] Call already processed", {
        callId,
        status: call.status,
      });
      return NextResponse.json({
        success: true,
        message: "Call already processed",
        status: call.status,
      });
    }

    // Get metadata and stored variables
    const metadata = call.metadata as Record<string, unknown> | null;
    let dynamicVariables = call.dynamic_variables as Record<
      string,
      unknown
    > | null;

    // --- ENRICHMENT: Fetch latest case data if linked ---
    if (call.case_id) {
      try {
        const caseInfo = await CasesService.getCaseWithEntities(
          supabase,
          call.case_id,
        );
        if (caseInfo?.entities) {
          console.log("[EXECUTE_CALL] Enriching with fresh case data", {
            caseId: call.case_id,
          });

          // Re-generate variables from fresh entities
          // We treat the stored variables as "Defaults"/Context (like clinic name)
          // and overwrite clinical parts with fresh data.
          const freshVars = buildDynamicVariables({
            baseVariables: {
              // Use stored values as base if available, otherwise defaults
              clinicName:
                (dynamicVariables?.clinic_name as string) ?? "Your Clinic",
              agentName: (dynamicVariables?.agent_name as string) ?? "Sarah",
              petName: caseInfo.entities.patient.name,
              ownerName: caseInfo.entities.patient.owner.name,
              appointmentDate: (dynamicVariables?.appointment_date ??
                "today") as string,
              callType:
                (dynamicVariables?.call_type as
                  | "discharge"
                  | "follow-up"
                  | undefined) ?? "discharge",
              clinicPhone: (dynamicVariables?.clinic_phone as string) ?? "",

              // Fresh Clinical Data overrides
              dischargeSummary:
                (dynamicVariables?.discharge_summary_content as string) ?? "", // Keep original summary or regenerate?
              // If we regenerate summary blindly we might lose specific instructions generated by the "Generate Summary" flow.
              // BUT, if the user updated the case entities (e.g. meds), we want that reflected.
              // The "discharge_summary_content" variable is usually the specific text.
              // The separate fields like "medications" are used by VAPI for structured questions.

              medications: caseInfo.entities.clinical.medications
                ?.map((m) => `${m.name} ${m.dosage ?? ""} ${m.frequency ?? ""}`)
                .join(", "),
              nextSteps: caseInfo.entities.clinical.followUpInstructions,
            },
            strict: false,
            useDefaults: true,
          });

          // Merge: Fresh Clinical Vars > Stored Vars
          // Wait, if I want fresh clinical vars to win, I should merge them ON TOP of stored.
          // But stored vars might have specific "discharge_summary_content" which is a text block.
          // Fresh variables from `buildDynamicVariables` uses `generateSummaryFromEntities` default if I passed it.
          // I passed `discharge_summary: dynamicVariables.discharge_summary_content`. So I preserved the summary.
          // But I updated `medications` and `nextSteps` from fresh entities.

          dynamicVariables = {
            ...dynamicVariables,
            ...freshVars.variables,
          };
        }
      } catch (enrichError) {
        console.error(
          "[EXECUTE_CALL] Failed to enrich with case data",
          enrichError,
        );
        // Continue with stored variables
      }
    }

    console.log("[EXECUTE_CALL] Final Dynamic variables", {
      callId,
      variableCount: dynamicVariables
        ? Object.keys(dynamicVariables).length
        : 0,
    });

    // Get VAPI configuration
    const assistantId = call.assistant_id;
    const phoneNumberId = call.phone_number_id;

    if (!assistantId) {
      console.error("[EXECUTE_CALL] Missing assistant_id");
      return NextResponse.json(
        { error: "Missing assistant_id configuration" },
        { status: 500 },
      );
    }

    if (!phoneNumberId) {
      console.error("[EXECUTE_CALL] Missing phone_number_id");
      return NextResponse.json(
        { error: "Missing phone_number_id configuration" },
        { status: 500 },
      );
    }

    // Prepare VAPI call parameters
    const vapiParams = {
      phoneNumber: call.customer_phone,
      assistantId,
      phoneNumberId,
      assistantOverrides: dynamicVariables
        ? {
            variableValues: dynamicVariables,
          }
        : undefined,
    };

    console.log("[EXECUTE_CALL] Calling VAPI API with parameters", {
      callId,
      phoneNumber: call.customer_phone,
      assistantId,
      phoneNumberId,
      hasAssistantOverrides: !!vapiParams.assistantOverrides,
    });

    // Execute call via VAPI
    const response = await createPhoneCall(vapiParams);

    console.log("[EXECUTE_CALL] VAPI API success", {
      callId,
      vapiCallId: response.id,
      status: response.status,
    });

    // Update database with VAPI response
    await supabase
      .from("scheduled_discharge_calls")
      .update({
        vapi_call_id: response.id,
        status: mapVapiStatus(response.status),
        started_at: response.startedAt ?? null,
        metadata: {
          ...metadata,
          executed_at: new Date().toISOString(),
        },
      })
      .eq("id", callId);

    return NextResponse.json({
      success: true,
      message: "Call executed successfully",
      vapiCallId: response.id,
      status: response.status,
    });
  } catch (error) {
    console.error("[EXECUTE_CALL] Error", {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });

    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 },
    );
  }
}

// Wrap handler with QStash signature verification
export const POST = verifySignatureAppRouter(handler);

/**
 * Health check endpoint
 */
export async function GET() {
  return NextResponse.json({
    status: "ok",
    message: "Execute call webhook is active",
  });
}
