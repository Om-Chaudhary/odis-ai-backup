import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { verifySignatureAppRouter } from "@upstash/qstash/dist/nextjs";
import { createServiceClient } from "@odis-ai/data-access/db/server";
import type { AIEnrichmentPayload } from "@odis-ai/integrations/qstash";

/**
 * AI Enrich Case Webhook
 *
 * POST /api/webhooks/ai-enrich-case
 *
 * This webhook is triggered by QStash to perform AI generation
 * for cases in the background after PIMS sync enrichment.
 *
 * Operations performed:
 * 1. Extract entities from consultation notes
 * 2. Generate structured discharge summary
 * 3. Generate call intelligence
 *
 * Security: QStash signature verification ensures only QStash can trigger this
 */

/**
 * Handle AI enrichment for a case
 */
async function handler(req: NextRequest) {
  const startTime = Date.now();

  try {
    console.log("[AI_ENRICH_CASE] Webhook triggered");

    // Parse request body
    const payload = (await req.json()) as AIEnrichmentPayload;
    const { caseId, userId, consultation } = payload;

    if (!caseId || !userId || !consultation) {
      console.error("[AI_ENRICH_CASE] Invalid payload", {
        hasCaseId: !!caseId,
        hasUserId: !!userId,
        hasConsultation: !!consultation,
      });
      return NextResponse.json(
        { error: "Invalid payload - missing required fields" },
        { status: 400 },
      );
    }

    // Get Supabase service client (bypasses RLS for background processing)
    const supabase = await createServiceClient();

    // Import case-ai functions dynamically
    const {
      extractEntitiesFromIdexx,
      autoGenerateDischargeSummary,
      generateAndStoreCallIntelligence,
    } = await import("@odis-ai/domain/cases");

    // Build raw data for entity extraction
    // Use dischargeSummary as fallback since IDEXX returns clinical content there
    const rawIdexxData: Record<string, unknown> = {
      consultation_notes: consultation.notes ?? consultation.dischargeSummary,
      products_services: consultation.productsServices,
      declined_products_services: consultation.declinedProductsServices,
      reason: consultation.reason,
    };

    // Step 1: Extract entities from clinical notes
    console.log("[AI_ENRICH_CASE] Extracting entities", { caseId });
    const entities = await extractEntitiesFromIdexx(rawIdexxData);

    if (!entities) {
      console.log(
        "[AI_ENRICH_CASE] Entity extraction returned null - insufficient data",
        {
          caseId,
          notesLength:
            (consultation.notes ?? consultation.dischargeSummary)?.length ?? 0,
        },
      );
      return NextResponse.json({
        success: true,
        caseId,
        skipped: true,
        reason: "insufficient_data",
        durationMs: Date.now() - startTime,
      });
    }

    console.log("[AI_ENRICH_CASE] Entities extracted", {
      caseId,
      patientName: entities.patient.name,
      hasDiagnoses: !!entities.clinical.diagnoses?.length,
    });

    // Step 2 & 3: Generate discharge summary and call intelligence in parallel
    const [summaryResult, intelligenceResult] = await Promise.all([
      autoGenerateDischargeSummary(supabase, userId, caseId, entities),
      generateAndStoreCallIntelligence(supabase, caseId, entities),
    ]);

    const result = {
      success: true,
      caseId,
      summary: summaryResult
        ? { id: summaryResult.summaryId }
        : { skipped: true },
      intelligence: intelligenceResult
        ? { questionCount: intelligenceResult.assessmentQuestions?.length ?? 0 }
        : { skipped: true },
      durationMs: Date.now() - startTime,
    };

    console.log("[AI_ENRICH_CASE] Completed", result);

    return NextResponse.json(result);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    const durationMs = Date.now() - startTime;

    console.error("[AI_ENRICH_CASE] Failed", {
      error: message,
      stack: error instanceof Error ? error.stack : undefined,
      durationMs,
    });

    // Return 200 to prevent QStash retries for non-transient errors
    // (e.g., missing API keys, invalid data)
    return NextResponse.json({
      success: false,
      error: message,
      durationMs,
    });
  }
}

// Wrap handler with QStash signature verification
export const POST = verifySignatureAppRouter(handler);

/**
 * Health check endpoint
 */
export async function GET() {
  return NextResponse.json({
    status: "ok",
    message: "AI enrich case webhook is active",
  });
}
